1 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
2 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
3 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
4 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
5 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
6 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
7 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
8 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
9 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
10 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
11 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
12 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
13 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
14 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
15 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
16 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
17 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
18 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
19 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
20 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
21 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
22 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
23 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
24 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
25 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
26 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
27 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
28 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
29 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
30 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
31 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
32 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
33 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
34 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
35 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
36 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
37 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
38 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
39 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
40 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
41 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
42 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
43 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
44 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
45 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
46 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
47 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
48 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
49 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
50 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
51 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
52 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
53 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
54 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
55 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
56 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
57 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
58 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
59 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
60 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
61 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
62 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
63 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
64 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
65 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
66 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
67 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
68 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
69 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
70 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
71 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
72 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
73 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
74 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
75 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
76 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
77 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
78 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
79 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
80 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
81 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
82 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
83 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
84 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
85 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
86 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
87 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
88 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
89 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
90 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
91 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
92 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
93 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
94 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
95 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
96 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
97 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
98 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
99 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
100 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
101 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
102 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
103 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
104 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
105 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
106 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
107 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
108 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
109 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
110 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
111 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
112 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
113 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
114 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
115 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
116 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
117 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
118 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
119 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
120 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
121 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
122 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
123 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
124 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
125 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
126 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
127 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
128 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
129 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
130 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
131 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
132 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
133 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
134 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
135 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
136 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
137 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
138 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
139 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
140 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
141 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
142 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
143 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
144 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
145 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
146 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
147 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
148 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
149 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
150 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
151 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
152 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
153 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
154 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
155 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
156 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
157 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
158 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
159 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
160 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
161 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
162 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
163 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
164 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
165 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
166 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
167 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
168 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
169 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
170 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
171 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
172 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
173 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
174 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
175 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
176 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
177 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
178 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
179 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
180 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
181 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
182 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
183 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
184 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
185 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
186 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
187 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
188 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
189 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
190 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
191 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
192 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
193 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
194 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
195 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
196 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
197 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
198 25808_1.sol
25808_1.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
199 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
200 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------