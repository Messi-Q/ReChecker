id,sequence_text,reentrancy,noreentrancy
"11719.sol
","function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,""Collect""); function() public payable { Deposit(); contract LogFile struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"30101.sol
",function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ,0,1
"31912.sol
","function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(""serveTx"",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); return (true,_id); ",0,1
"2072.sol
","function executeProposal(uint proposalNumber, bytes transactionBytecode) public { Proposal storage p = proposals[proposalNumber]; require(now > p.minExecutionDate && !p.executed && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); uint quorum = 0; uint yea = 0; uint nay = 0; for (uint i = 0; i <  p.votes.length; ++i) { Vote storage v = p.votes[i]; uint voteWeight = sharesTokenAddress.balanceOf(v.voter); quorum += voteWeight; if (v.inSupport) { yea += voteWeight; } else { nay += voteWeight; require(quorum >= minimumQuorum); if (yea > nay ) { p.executed = true; require(p.recipient.call.value(p.amount)(transactionBytecode)); p.proposalPassed = true; } else { p.proposalPassed = false; emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed); ",0,1
"PrivateBank.sol
","function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,""CashOut""); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"21999.sol
","function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); ",0,1
"23387.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"27248.sol
","function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; nonce = nonce + 1; require(destination.call.value(value)(data)); ",0,1
"36732.sol
",function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ,0,1
"32559.sol
","function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"15458.sol
","function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ) require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; return false; ",1,0
"12182.sol
","function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ",0,1
"37891.sol
",function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); ,0,1
"16925.sol
",function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ,1,0
"18145.sol
","function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"1123.sol
","function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); ",0,1
"18170.sol
","function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; ",0,1
"4598.sol
","function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); ",0,1
"39191.sol
","function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } return true; return false; uint constant DEFAULT_SEND_GAS = 100000; ",0,1
"1430.sol
","function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; ",0,1
"36968.sol
",function claim_bounty(){ if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ,0,1
"39705.sol
","function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, ""ETH"", """"); return foundationWallet.call.value(this.balance)(); ",0,1
"668.sol
","function call(address _to, bytes memory _data) public payable onlyWhitelistAdmin { require(_to != address(registrar)); (bool success,) = _to.call.value(msg.value)(_data); require(success); ",0,1
"21900.sol
","function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; contract GGPCToken is Crowdsale { string public name = ""Global game payment currency""; string public symbol = ""GGPC""; string public version = '1.0.2'; ",0,1
"28974.sol
","function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); s.update(_addr,count); Buy(msg.sender,count); function () public payable { pay(msg.sender,1); ",1,0
"22805.sol
","function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ",0,1
"16925.sol
",function withdraw() public{ assert(msg.sender.call.value(balances[msg.sender])()) ; balances[msg.sender] = 0; ,1,0
"Reentrance_01.sol
",function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; } userBalance[msg.sender] = 0; ,1,0
"23387.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){ if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"274.sol
","function buy(IMultiToken _mtkn, uint256 _minimumReturn, address[] _exchanges, bytes _datas, uint[] _datasIndexes, uint256[] _values) public payable { require(_datasIndexes.length == _exchanges.length + 1, ""buy: _datasIndexes should start with 0 and end with LENGTH""); require(_values.length == _exchanges.length, ""buy: _values should have the same length as _exchanges""); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; require(_exchanges[i].call.value(_values[i])(data), ""buy: exchange arbitrary call failed""); j = _mtkn.totalSupply(); uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; require(bestAmount >= _minimumReturn, ""buy: return value is too low""); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); ",1,0
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"34577.sol
","function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"33851.sol
","function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); ",0,1
"39662.sol
","function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; ",0,1
"10107.sol
","function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); emit Transfer(msg.sender, to, value, data); return true; ",0,1
"774.sol
","function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; if (!address(Bank).call.value(_com)(bytes4(keccak256(""deposit()""))))  {  } return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"3174.sol
","function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) { if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))){ _res = _p3d.add(_res); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) { if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))){ _res = _p3d.add(_res); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _long = _eth / 50; if(_long > 0) swapDeposit.transfer(_long); uint256 _p3d; if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != """") { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))) { uint256 __rID = rID_ + 1; round_[__rID].pot = round_[__rID].pot.add(_p3d); _p3d = 0; _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _long = _eth / 50; if(_long > 0) swapDeposit.transfer(_long); uint256 _p3d; if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != """") { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))) { uint256 __rID = rID_ + 1; round_[__rID].pot = round_[__rID].pot.add(_p3d); _p3d = 0; _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); ",0,1
"dumbDAO.sol
","function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; ",1,0
"cross-function-reentrancy-fixed.sol
",function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); ,0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"14579.sol
","function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); paid = true; emit Paid(netAmount, fee); ",0,1
"39932.sol
","function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(""refill(bytes32)"")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; ",0,1
"18425.sol
",function payout() public { uint balance = address(this).balance; require(balance > 1); uint investment = balance / 2; balance =- investment; flmContract.call.value(investment).gas(1000000)(); while (balance > 0) { uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout; if(payoutToSend > 0){ participants[payoutOrder].payout -= payoutToSend; balance -= payoutToSend; if(!participants[payoutOrder].etherAddress.send(payoutToSend)){ participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)(); if(balance > 0){ payoutOrder += 1; function payout() public { uint balance = address(this).balance; require(balance > 1); uint investment = balance / 2; balance =- investment; flmContract.call.value(investment).gas(1000000)(); while (balance > 0) { uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout; if(payoutToSend > 0){ participants[payoutOrder].payout -= payoutToSend; balance -= payoutToSend; if(!participants[payoutOrder].etherAddress.send(payoutToSend)){ participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)(); if(balance > 0){ payoutOrder += 1; ,0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"11705.sol
","function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw(token, msg.sender, value, tokens[token][msg.sender]); function withdraw(uint amount) public { commonWithdraw(0, amount); function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); ",0,1
"1403.sol
","function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); _transfer(msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ",1,0
"39994.sol
","function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; pragma solidity ^0.4.0; contract Math string constant VERSION = ""Math 0.0.1 \n""; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; ",0,1
"17215.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; ",0,1
"37498.sol
","function execute(address _to, uint _value, bytes _data) external onlyowner payable returns (bool){ return _to.call.value(_value)(_data); ",1,0
"27248.sol
","function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); address lastAdd = address(0); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; nonce = nonce + 1; require(destination.call.value(value)(data)); ",0,1
"40353.sol
","function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"37498.sol
","function execute(address _to, uint _value, bytes _data) external onlyowner payable returns (bool){ return _to.call.value(_value)(_data); ",1,0
"EtherStore.sol
",function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; ,1,0
"5515.sol
","function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"10970.sol
","function execute(address _to, uint256 _value, bytes _data) mostOwner(keccak256(msg.data)) external returns (bool){ require(_to != address(0)); Withdraw(_to, _value, msg.sender); return _to.call.value(_value)(_data); ",1,0
"21241.sol
",function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; ,0,1
"2189.sol
","function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; bool allocated = false; ",1,0
"24007.sol
",function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ,1,0
"36968.sol
",function claim_bounty(){ if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ,0,1
"3050.sol
","function withdraw() external; contract BlankContract { constructor() public {} contract AirDropWinner { FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1); constructor() public { if(!address(fomo3d).call.value(0.1 ether)()) { fomo3d.withdraw(); selfdestruct(msg.sender); contract PonziPwn { FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1); address private admin; uint256 private blankContractGasLimit = 20000; uint256 private pwnContractGasLimit = 250000; uint256 private gasPrice = 10; uint256 private gasPriceInWei = gasPrice*1e9; uint256 private blankContractCost = blankContractGasLimit*gasPrice ; uint256 private pwnContractCost = pwnContractGasLimit*gasPrice; uint256 private maxAmount = 10 ether; modifier onlyAdmin() { require(msg.sender == admin); constructor() public { admin = msg.sender; function deployContracts(uint256 _nContracts,address _newSender) private { for(uint256 _i; _i < _nContracts; _i++) { if(_i++ == _nContracts) { address(_newSender).call.value(0.1 ether)(); new AirDropWinner(); new BlankContract(); ",0,1
"26523.sol
","function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[""price""]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[""price_poοl""]) final_reward = parameters[""price_poοl""]; require(msg.sender.call.value(final_reward)()); parameters[""price_poοl""] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; ",1,0
"16057.sol
",function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); ,0,1
"3985.sol
","function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = ""\x19Ethereum Signed Message:\n32""; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); ",0,1
"35661.sol
","function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); ",0,1
"856.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) emit Execution(transactionId); else { emit ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"12182.sol
","function transferEther(address to, uint256 amount) public returns (bool) { require(msg.sender == owner); return to.call.value(amount)(); function() public payable {} contract Controller is ControllerStorage, Ownable, HasWorkers { event CreatedUserWallet(address _wallet); event WithdrawEth(address _wallet, address _to, uint256 _amount); event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount); event ChangedForward(address _old, address _new, address _operator); constructor() public { setForward(msg.sender); function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) { return destination.call.value(value)(_bytes); function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) { uint256 size = wallets.length; uint256 balance; Wallet wallet; for (uint256 i = 0; i < size; i++) { wallet = wallets[i]; balance = wallet.balance; if (wallet.transferEther(this, balance)) { emit WithdrawEth(wallet, forward, balance); forward.call.value(address(this).balance)(); return true; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"39127.sol
","function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); ",0,1
"1879.sol
","function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); ",0,1
"35617.sol
","function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ",0,1
"14458.sol
","function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ",0,1
"2387.sol
","function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ",1,0
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"23421.sol
","function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); return true; ",0,1
"19402.sol
","function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); ",0,1
"28687.sol
","function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,""CashOut""); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"37836.sol
","function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); ",0,1
"28687.sol
","function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,""CashOut""); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"39684.sol
","function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, """", """", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries("""", 0, """", """", 0x0); contract SeriesFactory { address public seriesFactory; address public owner; ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"38724.sol
","function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; ",1,0
"970.sol
","function withdraw(uint amount) { if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"9221.sol
",function bet() payable if ((random()%2==1) && (msg.value == 1 ether) && (!locked)) if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) if (gameOwner==msg.sender) if (!msg.sender.call.value( amount * (1 ether))()) throw; ,0,1
"40366.sol
","function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; contract BranchSender { bool public isRightBranch; ",0,1
"1403.sol
","function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public returns (bool success) { bytes memory empty; _transfer( msg.sender, to, value, empty ); return true; function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); _transfer(msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer(msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ",1,0
"26523.sol
","function claim_reward(uint uid, bytes32 passcode) public payable{ require(msg.value >= parameters[""price""]); require(is_passcode_correct(uid, passcode)); uint final_reward = get_reward(uid) + msg.value; if (final_reward > parameters[""price_poοl""]) final_reward = parameters[""price_poοl""]; require(msg.sender.call.value(final_reward)()); parameters[""price_poοl""] -= final_reward; if (uid + 1 < users.length) users[uid] = users[users.length - 1]; users.length -= 1; ",1,0
"cross-function-reentrancy.sol
",function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {  throw;} rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; ,1,0
"39019.sol
",function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; ,0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"Reentrance_02.sol
",function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; function() public payable {} ,1,0
"SendBalance.sol
",function withdrawBalance(){ if(!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; ,1,0
"40090.sol
","function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"11719.sol
","function Collect(uint _am) public payable { if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) { if(msg.sender.call.value(_am)())  { balances[msg.sender]-=_am; Log.AddMessage(msg.sender,_am,""Collect""); function() public payable { Deposit(); contract LogFile struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
