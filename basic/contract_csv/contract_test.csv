id,sequence_text,reentrancy,noreentrancy
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"Victim.sol
",function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; ,1,0
"21604.sol
","function buyToken() public payable { address currentOwner; uint256 currentPrice; uint256 paidTooMuch; uint256 payment; if (tokenPrice < tokenPrice2) { currentOwner = tokenOwner; currentPrice = tokenPrice; require(tokenOwner2 != msg.sender); } else { currentOwner = tokenOwner2; currentPrice = tokenPrice2; require(tokenOwner != msg.sender); require(msg.value >= currentPrice); paidTooMuch = msg.value.sub(currentPrice); payment = currentPrice.div(2); if (tokenPrice < tokenPrice2) { tokenPrice = currentPrice.mul(110).div(50); tokenOwner = msg.sender; } else { tokenPrice2 = currentPrice.mul(110).div(50); tokenOwner2 = msg.sender; lastBuyBlock = block.number; flips++; Transfer(currentOwner, msg.sender, currentPrice); if (currentOwner != address(0)) { payoutRound = getRoundId()-3; currentOwner.call.value(payment).gas(24000)(); if (paidTooMuch > 0) msg.sender.transfer(paidTooMuch); function finishRound() public { require(tokenPrice > tokenStartPrice); require(lastBuyBlock + newRoundDelay < block.number); lastBuyBlock = block.number; address owner = tokenOwner; uint price = tokenPrice; if (tokenPrice2>tokenPrice) { owner = tokenOwner2; price = tokenPrice2; uint lastPaidPrice = price.mul(50).div(110); uint win = this.balance - lastPaidPrice; if (highestPrice < lastPaidPrice) { richestPlayer = owner; highestPrice = lastPaidPrice; richestRoundId = getRoundId()-1; tokenPrice = tokenStartPrice; tokenPrice2 = tokenStartPrice2; tokenOwner = address(0); tokenOwner2 = address(0); payoutRound = getRoundId()-1; flips = 0; round++; NewRound(lastPaidPrice, win / 2, owner); contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20); owner.call.value(lastPaidPrice + win / 2).gas(24000)(); if (richestPlayer!=address(0)) { payoutRound = richestRoundId; RichestBonus(win / 10, richestPlayer); richestPlayer.call.value(win / 10).gas(24000)(); function finishRound() public { require(tokenPrice > tokenStartPrice); require(lastBuyBlock + newRoundDelay < block.number); lastBuyBlock = block.number; address owner = tokenOwner; uint price = tokenPrice; if (tokenPrice2>tokenPrice) { owner = tokenOwner2; price = tokenPrice2; uint lastPaidPrice = price.mul(50).div(110); uint win = this.balance - lastPaidPrice; if (highestPrice < lastPaidPrice) { richestPlayer = owner; highestPrice = lastPaidPrice; richestRoundId = getRoundId()-1; tokenPrice = tokenStartPrice; tokenPrice2 = tokenStartPrice2; tokenOwner = address(0); tokenOwner2 = address(0); payoutRound = getRoundId()-1; flips = 0; round++; NewRound(lastPaidPrice, win / 2, owner); contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20); owner.call.value(lastPaidPrice + win / 2).gas(24000)(); if (richestPlayer!=address(0)) { payoutRound = richestRoundId; RichestBonus(win / 10, richestPlayer); richestPlayer.call.value(win / 10).gas(24000)(); ",0,1
"14945.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; ",1,0
"39912.sol
","function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(""buy()"")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(""transfer(address,uint256)"")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; ",0,1
"30046.sol
",function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); ,1,0
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"39190.sol
","function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) { throw; return true; return false; uint constant DEFAULT_SEND_GAS = 100000; function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); ",0,1
"3211.sol
","function someFunction() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction2() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit2()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction3() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit3()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction4() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit4()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); ",1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"39749.sol
","function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; function safeWithdraw() public onlyAfterDeadline  { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; function emergencyWithdraw() public isEmergency  { calcRefund(msg.sender); ",0,1
"27263.sol
","function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, """", msg.sender, owner); investors[msg.sender] -= amount; function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, """", msg.sender, owner); ",1,0
"2387.sol
","function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ",1,0
"2072.sol
","function executeProposal(uint proposalNumber, bytes transactionBytecode) public { Proposal storage p = proposals[proposalNumber]; require(now > p.minExecutionDate && !p.executed && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); uint quorum = 0; uint yea = 0; uint nay = 0; for (uint i = 0; i <  p.votes.length; ++i) { Vote storage v = p.votes[i]; uint voteWeight = sharesTokenAddress.balanceOf(v.voter); quorum += voteWeight; if (v.inSupport) { yea += voteWeight; } else { nay += voteWeight; require(quorum >= minimumQuorum); if (yea > nay ) { p.executed = true; require(p.recipient.call.value(p.amount)(transactionBytecode)); p.proposalPassed = true; } else { p.proposalPassed = false; emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed); ",0,1
"9611.sol
","function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, ""ss-guard""); txMutex3847834 = true; require(toAddr.call.value(amount)(data), ""ss-failed""); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, """", amount); ",0,1
"12114.sol
","function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal { wethToken.withdraw(wethAmt); require(msg.sender.call.value(wethAmt)()); function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint) { require(payToken.transferFrom(msg.sender, this, payAmt)); if (payToken.allowance(this, otc) < payAmt) { payToken.approve(otc, uint(-1)); uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt); (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt); require(wethToken.transfer(owner, feeAmt)); withdrawAndSend(wethToken, wethAmtRemainder); return wethAmtRemainder; function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) { uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt); require(payAmtNow <= maxPayAmt); require(payToken.transferFrom(msg.sender, this, payAmtNow)); if (payToken.allowance(this, otc) < payAmtNow) { payToken.approve(otc, uint(-1)); payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow); (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt); require(wethToken.transfer(owner, feeAmt)); withdrawAndSend(wethToken, wethAmtRemainder); function() public payable {} ",0,1
"simple_dao_fixed.sol
",function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); ,0,1
"18438.sol
",function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); ,0,1
"33450.sol
",function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); ,0,1
"EtherStore.sol
",function withdrawFunds (uint256 _weiToWithdraw) public { require(balances[msg.sender] >= _weiToWithdraw); require(_weiToWithdraw <= withdrawalLimit); require(now >= lastWithdrawTime[msg.sender] + 1 weeks); require(msg.sender.call.value(_weiToWithdraw)()); balances[msg.sender] -= _weiToWithdraw; lastWithdrawTime[msg.sender] = now; ,1,0
"13952.sol
","function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ",0,1
"10970.sol
","function execute(address _to, uint256 _value, bytes _data) mostOwner(keccak256(msg.data)) external returns (bool){ require(_to != address(0)); Withdraw(_to, _value, msg.sender); return _to.call.value(_value)(_data); ",1,0
"14995.sol
","function fund() public payable { if (dateSaleStarted==0 || now < dateSaleStarted) return _errorBuyingTokens(""CrowdSale has not yet started.""); if (now > dateSaleEnded) return _errorBuyingTokens(""CrowdSale has ended.""); if (totalRaised >= hardCap) return _errorBuyingTokens(""HardCap has been reached.""); if (msg.value % 1000000000 != 0) return _errorBuyingTokens(""Must send an even amount of GWei.""); if (!wasSaleStarted) { wasSaleStarted = true; emit SaleStarted(now); uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value; uint _numTokens = getTokensFromEth(_amtToFund); token.mint(msg.sender, _numTokens); totalRaised += _amtToFund; emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens); if (totalRaised < softCap) { amtFunded[msg.sender] += _amtToFund; uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0; if (_refund > 0){ require(msg.sender.call.value(_refund)()); emit UserRefunded(now, msg.sender, _refund); function endSale() public { require(wasSaleStarted && !wasSaleEnded); require(totalRaised >= hardCap || now > dateSaleEnded); wasSaleEnded = true; wasSoftCapMet = totalRaised >= softCap; if (!wasSoftCapMet) { token.mint(wallet, 1e30); emit SaleFailed(now); return; token.freeze(false); uint _lockerAmt = token.totalSupply() / 4; token.mint(locker, _lockerAmt); locker.startVesting(_lockerAmt, 600); uint _capitalAmt = (totalRaised * capitalPctBips) / 10000; if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance; treasury.addCapital.value(_capitalAmt)(); if (wallet.call.value(address(this).balance)()) {} emit SaleSuccessful(now); function refund() public { require(wasSaleEnded && !wasSoftCapMet); require(amtFunded[msg.sender] > 0); uint _amt = amtFunded[msg.sender]; amtFunded[msg.sender] = 0; require(msg.sender.call.value(_amt)()); emit UserRefunded(now, msg.sender, _amt); function fundCapital() public payable { if (!wasSaleEnded) return _errorBuyingTokens(""Sale has not ended.""); if (!wasSoftCapMet) return _errorBuyingTokens(""SoftCap was not met.""); uint _amtNeeded = capitalFundable(); uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value; if (_amount == 0) { return _errorBuyingTokens(""No capital is needed.""); totalRaised += _amount; token.mint(msg.sender, _amount); treasury.addCapital.value(_amount)(); emit BuyTokensSuccess(now, msg.sender, _amount, _amount); uint _refund = msg.value > _amount ? msg.value - _amount : 0; if (_refund > 0) { require(msg.sender.call.value(_refund)()); emit UserRefunded(now, msg.sender, _refund); function _errorBuyingTokens(string _reason) private { require(msg.sender.call.value(msg.value)()); emit BuyTokensFailure(now, msg.sender, _reason); function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); function collect() public { require(msg.sender == owner); token.collectOwedDividends(); uint _amount = address(this).balance; if (_amount > 0) require(owner.call.value(_amount)()); emit Collected(now, owner, _amount); ",1,0
"14995.sol
","function fund() public payable { if (dateSaleStarted==0 || now < dateSaleStarted) return _errorBuyingTokens(""CrowdSale has not yet started.""); if (now > dateSaleEnded) return _errorBuyingTokens(""CrowdSale has ended.""); if (totalRaised >= hardCap) return _errorBuyingTokens(""HardCap has been reached.""); if (msg.value % 1000000000 != 0) return _errorBuyingTokens(""Must send an even amount of GWei.""); if (!wasSaleStarted) { wasSaleStarted = true; emit SaleStarted(now); uint _amtToFund = (totalRaised + msg.value) > hardCap ? hardCap - totalRaised : msg.value; uint _numTokens = getTokensFromEth(_amtToFund); token.mint(msg.sender, _numTokens); totalRaised += _amtToFund; emit BuyTokensSuccess(now, msg.sender, _amtToFund, _numTokens); if (totalRaised < softCap) { amtFunded[msg.sender] += _amtToFund; uint _refund = msg.value > _amtToFund ? msg.value - _amtToFund : 0; if (_refund > 0){ require(msg.sender.call.value(_refund)()); emit UserRefunded(now, msg.sender, _refund); function endSale() public { require(wasSaleStarted && !wasSaleEnded); require(totalRaised >= hardCap || now > dateSaleEnded); wasSaleEnded = true; wasSoftCapMet = totalRaised >= softCap; if (!wasSoftCapMet) { token.mint(wallet, 1e30); emit SaleFailed(now); return; token.freeze(false); uint _lockerAmt = token.totalSupply() / 4; token.mint(locker, _lockerAmt); locker.startVesting(_lockerAmt, 600); uint _capitalAmt = (totalRaised * capitalPctBips) / 10000; if (address(this).balance < _capitalAmt) _capitalAmt = address(this).balance; treasury.addCapital.value(_capitalAmt)(); if (wallet.call.value(address(this).balance)()) {} emit SaleSuccessful(now); function refund() public { require(wasSaleEnded && !wasSoftCapMet); require(amtFunded[msg.sender] > 0); uint _amt = amtFunded[msg.sender]; amtFunded[msg.sender] = 0; require(msg.sender.call.value(_amt)()); emit UserRefunded(now, msg.sender, _amt); function fundCapital() public payable { if (!wasSaleEnded) return _errorBuyingTokens(""Sale has not ended.""); if (!wasSoftCapMet) return _errorBuyingTokens(""SoftCap was not met.""); uint _amtNeeded = capitalFundable(); uint _amount = msg.value > _amtNeeded ? _amtNeeded : msg.value; if (_amount == 0) { return _errorBuyingTokens(""No capital is needed.""); totalRaised += _amount; token.mint(msg.sender, _amount); treasury.addCapital.value(_amount)(); emit BuyTokensSuccess(now, msg.sender, _amount, _amount); uint _refund = msg.value > _amount ? msg.value - _amount : 0; if (_refund > 0) { require(msg.sender.call.value(_refund)()); emit UserRefunded(now, msg.sender, _refund); function _errorBuyingTokens(string _reason) private { require(msg.sender.call.value(msg.value)()); emit BuyTokensFailure(now, msg.sender, _reason); function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); function collect() public { require(msg.sender == owner); token.collectOwedDividends(); uint _amount = address(this).balance; if (_amount > 0) require(owner.call.value(_amount)()); emit Collected(now, owner, _amount); ",1,0
"3211.sol
","function someFunction() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction2() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit2()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction3() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit3()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); function someFunction4() public payable { gasBefore_ = gasleft(); if (!address(Jekyll_Island_Inc).call.value(msg.value)(bytes4(keccak256(""deposit4()"")))) { depositSuccessful_ = false; gasAfter_ = gasleft(); } else { depositSuccessful_ = true; successfulTransactions_++; gasAfter_ = gasleft(); ",1,0
"21697.sol
",function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ,1,0
"9920.sol
","function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); contract DSMath { ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"27159.sol
","function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ",1,0
"5629.sol
","constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ",0,1
"39817.sol
","function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"14945.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; ",1,0
"40090.sol
","function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); ",0,1
"Bank_attack.sol
","function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(""Deposit()""))); function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); ",1,0
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"10297.sol
","function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); ",0,1
"28869.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"18170.sol
","function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() { require(_amount <= wingsETHRewards); require(_contract.call.value(_amount)()); wingsETHRewards -= _amount; ",0,1
"39326.sol
","function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ",0,1
"40092.sol
",function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; ,0,1
"14741.sol
","function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); ",0,1
"29601.sol
","function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); Transfer(from, to, value, data); return status; function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, """"); function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, """"); function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; ",0,1
"31565.sol
",function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ,0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"4591.sol
","function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; ",0,1
"38873.sol
","function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if (!_to.call.value(_value)(_data)) { throw; return 0; _r = keccak256(msg.data, block.number); if (!confirm(_r) && txs[_r].to == 0) { txs[_r].to = _to; txs[_r].value = _value; txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (txs[_h].to != 0) { if (!txs[_h].to.call.value(txs[_h].value)(txs[_h].data)) { throw; MultiTransact(msg.sender, _h, txs[_h].value, txs[_h].to, txs[_h].data); delete txs[_h]; return true; ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"2071.sol
","function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _com; _com = 0; uint256 _long = _eth / 100; address(otherF3DInc).call.value(_long)(bytes4(keccak256(""deposit()""))); uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _com; _com = 0; uint256 _long = _eth / 100; address(otherF3DInc).call.value(_long)(bytes4(keccak256(""deposit()""))); uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); ",0,1
"40341.sol
","function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); contract MoneyRounderMixin { function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); contract KingdomFactory { ",0,1
"40092.sol
",function withdrawPayments() external  returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; ,0,1
"17518.sol
","function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ",0,1
"22074.sol
",function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ,1,0
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"39912.sol
","function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(""buy()"")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(""transfer(address,uint256)"")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; ",0,1
"21390.sol
","function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==""In"")   { FundsMove(msg.value,""In"",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, ""Out"", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,"""",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, ""In"", to,admin); ",1,0
"39973.sol
","function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ",0,1
"8342.sol
","function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); ",0,1
"39019.sol
",function CreateTokens() { if (tokensCreated > 0) return; uint amount = amountRaised * (100 - rewardPercentage) / 100; if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw; tokensCreated = tokenContract.balanceOf(this); tokenCreator = msg.sender; ,0,1
"37474.sol
","function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; ",0,1
"2387.sol
","function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ",1,0
"16057.sol
",function callFirstTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); firstTarget.call.value(msg.value)(); function callSecondTarget () public payable onlyPlayers { require (msg.value >= 0.005 ether); secondTarget.call.value(msg.value)(); function winPrize() public payable onlyOwner { owner.call.value(1 wei)(); ,0,1
"39973.sol
","function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return (false, _safeFalse()); if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); return (true, _applyRefund(startGas)); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); ",0,1
"14994.sol
","function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); ",0,1
"40469.sol
","function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; _to.call.value(msg.value)(_data); return _applyRefund(startGas); ",0,1
"740.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender]  && now > unlockUnixTime[_to]); if (isContract(_to)) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"27398.sol
","function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); ",0,1
"27188.sol
","function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, """", msg.sender, owner); function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, ""Dividend payment"", msg.sender, owner); function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, ""Owner transfer"", target, owner); ",1,0
"10711.sol
","function withdrawTo(address _to) public auth { require(_to.call.value(address(this).balance)()); function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal { wethToken.withdraw(wethAmt); require(_to.call.value(wethAmt)()); function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) { wethToken.deposit.value(msg.value)(); if (wethToken.allowance(this, otc) < msg.value) { wethToken.approve(otc, uint(-1)); wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value); buyAmt = min(buyAmt, buyToken.balanceOf(this)); (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); require(buyToken.transfer(owner, feeAmt)); require(buyToken.transfer(msg.sender, buyAmtRemainder)); unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) { wethToken.deposit.value(msg.value)(); if (wethToken.allowance(this, otc) < msg.value) { wethToken.approve(otc, uint(-1)); wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value); buyAmt = min(buyAmt, buyToken.balanceOf(this)); (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); require(buyToken.transfer(owner, feeAmt)); require(buyToken.transfer(msg.sender, buyAmtRemainder)); unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); ",0,1
"21241.sol
",function finish() onlyOwner saleCompletedSuccessfully public { uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; ,0,1
"22074.sol
",function Collect(uint _am) public payable { if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) { msg.sender.call.value(_am); Bal[msg.sender]-=_am; ,1,0
"39190.sol
","function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) { throw; return true; return false; uint constant DEFAULT_SEND_GAS = 100000; function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); function execute(Call storage self, uint start_gas, address executor, uint overhead, uint extraGas) public { FutureCall call = FutureCall(this); self.wasCalled = true; if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(); else if (self.abiSignature == EMPTY_SIGNATURE) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData); else if (self.callData.length == 0) { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature); else { self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData); call.origin().call(bytes4(sha3(""updateDefaultPayment()""))); uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice); uint basePayment; if (self.claimer == executor) { basePayment = self.claimAmount; else { basePayment = call.basePayment(); uint payment = self.claimerDeposit + basePayment * gasScalar / 100; uint donation = call.baseDonation() * gasScalar / 100; self.claimerDeposit = 0; uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas); payment = sendSafe(executor, payment + gasCost); donation = sendSafe(creator, donation); CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful); event Cancelled(address indexed cancelled_by); ",0,1
"1751.sol
","function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; ",1,0
"17009.sol
","function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); ",1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"17573.sol
","function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); ERC223Transfer(_from, _to, _amount, _data); return true; function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); ",0,1
"2021.sol
","function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"37645.sol
",function endSale() { if (saleHasEnded) throw; if (!minCapReached) throw; if (msg.sender != executor) throw; uint256 additionalSFT = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION); uint256 totalSupplySafe = totalSupply.add(additionalSFT); uint256 devShare = additionalSFT; totalSupply = totalSupplySafe; balances[devSFTDestination] = devShare; saleHasEnded = true; if (this.balance > 0) { if (!devETHDestination.call.value(this.balance)()) throw; function withdrawFunds() { if (0 == this.balance) throw; if (!minCapReached) throw; if (!devETHDestination.call.value(this.balance)()) throw; ,0,1
"36645.sol
",function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); ,0,1
"39644.sol
","function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); ",0,1
"74.sol
","function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(address(this).call.value(msg.value)(data)); contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {} ",0,1
"Reentrance_02.sol
",function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; function() public payable {} ,1,0
"16643.sol
","function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); ",0,1
"25196.sol
","function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); ",1,0
"37707.sol
",function claimBounty() preventTheft { uint balance = bountyAmount[msg.sender]; if (msg.sender.call.value(balance)()) { totalBountyAmount -= balance; bountyAmount[msg.sender] = 0; ,1,0
"40500.sol
","function payOut(address _recipient, uint _amount) returns (bool) { if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner)) throw; if (_recipient.call.value(_amount)()) { PayOut(_recipient, _amount); return true; } else { return false; contract TokenInterface { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function createTokenProxy(address _tokenHolder) returns (bool success) { if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) { uint token = (msg.value * 20) / divisor(); extraBalance.call.value(msg.value - token)(); balances[_tokenHolder] += token; totalSupply += token; weiGiven[_tokenHolder] += msg.value; CreatedToken(_tokenHolder, token); if (totalSupply >= minTokensToCreate && !isFueled) { isFueled = true; FuelingToDate(totalSupply); return true; throw; function refund() noEther { if (now > closingTime && !isFueled) { if (extraBalance.balance >= extraBalance.accumulatedInput()) extraBalance.payOut(address(this), extraBalance.accumulatedInput()); if (msg.sender.call.value(weiGiven[msg.sender])()) { Refund(msg.sender, weiGiven[msg.sender]); totalSupply -= balances[msg.sender]; balances[msg.sender] = 0; weiGiven[msg.sender] = 0; function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) { Proposal p = proposals[_proposalID]; uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod; if (p.open && now > p.votingDeadline + waitPeriod) { closeProposal(_proposalID); return; if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) { throw; if (!isRecipientAllowed(p.recipient)) { closeProposal(_proposalID); p.creator.send(p.proposalDeposit); return; bool proposalCheck = true; if (p.amount > actualBalance()) proposalCheck = false; uint quorum = p.yea + p.nay; if (_transactionData.length >= 4 && _transactionData[0] == 0x68 && _transactionData[1] == 0x37 && _transactionData[2] == 0xff && _transactionData[3] == 0x1e && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) { proposalCheck = false; if (quorum >= minQuorum(p.amount)) { if (!p.creator.send(p.proposalDeposit)) throw; lastTimeMinQuorumMet = now; if (quorum > totalSupply / 5) minQuorumDivisor = 5; if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) { if (!p.recipient.call.value(p.amount)(_transactionData)) throw; p.proposalPassed = true; _success = true; if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) { rewardToken[address(this)] += p.amount; totalRewardToken += p.amount; closeProposal(_proposalID); ProposalTallied(_proposalID, _success, quorum); function newContract(address _newContract){ if (msg.sender != address(this) || !allowedRecipients[_newContract]) return; if (!_newContract.call.value(address(this).balance)()) { throw; rewardToken[_newContract] += rewardToken[address(this)]; rewardToken[address(this)] = 0; DAOpaidOut[_newContract] += DAOpaidOut[address(this)]; DAOpaidOut[address(this)] = 0; ",1,0
"40589.sol
","function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; ",0,1
"30301.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"35649.sol
",function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,0,1
"347.sol
","function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); ",0,1
"simple_dao.sol
",function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; ,1,0
"14458.sol
","function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){ require(_to != address(0)); if(isContract(_to)) { if(accountBalances[msg.sender].addressBalance < _value){ revert(); if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){ revert(); isNewRound(); subFromAddressBalancesInfo(msg.sender, _value); addToAddressBalancesInfo(_to, _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(msg.sender, _to, _value, _data); ",0,1
"36334.sol
",function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); ,0,1
"40425.sol
","function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ",0,1
"27334.sol
",function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ,0,1
"18425.sol
",function payout() public { uint balance = address(this).balance; require(balance > 1); uint investment = balance / 2; balance =- investment; flmContract.call.value(investment).gas(1000000)(); while (balance > 0) { uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout; if(payoutToSend > 0){ participants[payoutOrder].payout -= payoutToSend; balance -= payoutToSend; if(!participants[payoutOrder].etherAddress.send(payoutToSend)){ participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)(); if(balance > 0){ payoutOrder += 1; function payout() public { uint balance = address(this).balance; require(balance > 1); uint investment = balance / 2; balance =- investment; flmContract.call.value(investment).gas(1000000)(); while (balance > 0) { uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout; if(payoutToSend > 0){ participants[payoutOrder].payout -= payoutToSend; balance -= payoutToSend; if(!participants[payoutOrder].etherAddress.send(payoutToSend)){ participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)(); if(balance > 0){ payoutOrder += 1; ,0,1
"35421.sol
","function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); if ( 0==this.balance) { Bankrupt(); function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); }  else { ",0,1
"cross-function-reentrancy-fixed.sol
",function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); ,0,1
"40500.sol
","function payOut(address _recipient, uint _amount) returns (bool) { if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner)) throw; if (_recipient.call.value(_amount)()) { PayOut(_recipient, _amount); return true; } else { return false; contract TokenInterface { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; function createTokenProxy(address _tokenHolder) returns (bool success) { if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) { uint token = (msg.value * 20) / divisor(); extraBalance.call.value(msg.value - token)(); balances[_tokenHolder] += token; totalSupply += token; weiGiven[_tokenHolder] += msg.value; CreatedToken(_tokenHolder, token); if (totalSupply >= minTokensToCreate && !isFueled) { isFueled = true; FuelingToDate(totalSupply); return true; throw; function refund() noEther { if (now > closingTime && !isFueled) { if (extraBalance.balance >= extraBalance.accumulatedInput()) extraBalance.payOut(address(this), extraBalance.accumulatedInput()); if (msg.sender.call.value(weiGiven[msg.sender])()) { Refund(msg.sender, weiGiven[msg.sender]); totalSupply -= balances[msg.sender]; balances[msg.sender] = 0; weiGiven[msg.sender] = 0; function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) { Proposal p = proposals[_proposalID]; uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod; if (p.open && now > p.votingDeadline + waitPeriod) { closeProposal(_proposalID); return; if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) { throw; if (!isRecipientAllowed(p.recipient)) { closeProposal(_proposalID); p.creator.send(p.proposalDeposit); return; bool proposalCheck = true; if (p.amount > actualBalance()) proposalCheck = false; uint quorum = p.yea + p.nay; if (_transactionData.length >= 4 && _transactionData[0] == 0x68 && _transactionData[1] == 0x37 && _transactionData[2] == 0xff && _transactionData[3] == 0x1e && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) { proposalCheck = false; if (quorum >= minQuorum(p.amount)) { if (!p.creator.send(p.proposalDeposit)) throw; lastTimeMinQuorumMet = now; if (quorum > totalSupply / 5) minQuorumDivisor = 5; if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) { if (!p.recipient.call.value(p.amount)(_transactionData)) throw; p.proposalPassed = true; _success = true; if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) { rewardToken[address(this)] += p.amount; totalRewardToken += p.amount; closeProposal(_proposalID); ProposalTallied(_proposalID, _success, quorum); function newContract(address _newContract){ if (msg.sender != address(this) || !allowedRecipients[_newContract]) return; if (!_newContract.call.value(address(this).balance)()) { throw; rewardToken[_newContract] += rewardToken[address(this)]; rewardToken[address(this)] = 0; DAOpaidOut[_newContract] += DAOpaidOut[address(this)]; DAOpaidOut[address(this)] = 0; ",1,0
