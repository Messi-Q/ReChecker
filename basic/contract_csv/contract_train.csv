id,sequence_text,reentrancy,noreentrancy
"Victim.sol
",function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; balances[msg.sender] -= _amount; ,1,0
"4591.sol
","function finishDistribution() onlyOwner canDistr public returns (bool) { crowdsaleClosed = true; uint256 amount = tokenReward.sub(amountRaisedIsc); balances[beneficiary] = balances[beneficiary].add(amount); emit Transfer(address(0), beneficiary, amount); require(msg.sender.call.value(amountRaised)()); return true; ",0,1
"2301.sol
","function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); ",0,1
"21390.sol
","function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  { if(msg.sender != address(this)) throw; if(_operation==""In"")   { FundsMove(msg.value,""In"",_to); investors[_to] += _am; }  else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; }  else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; if(_to.call.value(_am)()==false) throw; investors[_to] -= _am; FundsMove(_am, ""Out"", _to); function() payable { In(msg.sender); function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,"""",msg.sender,admin); function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, ""In"", to,admin); ",1,0
"39749.sol
","function calcRefund(address _addressToRefund) internal { uint amount = balanceOf[_addressToRefund]; balanceOf[_addressToRefund] = 0; if (amount > 0) { if (_addressToRefund.call.value(amount)()) { LogFundTransfer(_addressToRefund, amount, false); } else { balanceOf[_addressToRefund] = amount; function safeWithdraw() public onlyAfterDeadline  { if (amountRaised >= fundingGoal){ fundingGoalReached = true; LogGoalReached(bankRollBeneficiary, amountRaised); crowdsaleClosed = true; if (!fundingGoalReached) { calcRefund(msg.sender); if (msg.sender == owner && fundingGoalReached) { bankrollBeneficiaryAmount = (this.balance*80)/100; if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) { LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false); etherollBeneficiaryAmount = this.balance; if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw; LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false); } else { fundingGoalReached = false; function emergencyWithdraw() public isEmergency  { calcRefund(msg.sender); ",0,1
"9221.sol
",function bet() payable if ((random()%2==1) && (msg.value == 1 ether) && (!locked)) if (!msg.sender.call.value(2 ether)()) throw; function releaseFunds(uint amount) if (gameOwner==msg.sender) if (!msg.sender.call.value( amount * (1 ether))()) throw; ,0,1
"14274.sol
","function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); TokenStore(_store).depositToken(_tokenGet, totalValue); TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"30178.sol
","function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; ",0,1
"39932.sol
","function process(bytes32 _destination) payable returns (bool) { if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(""refill(bytes32)"")); if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw; return true; contract Invoice is Mortal { address   public signer; uint      public closeBlock; Comission public comission; string    public description; bytes32   public beneficiary; uint      public value; ",0,1
"40241.sol
","function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ",0,1
"39269.sol
","function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; TransactionFailed(tx.from, tx.to, tx.value); return false; ",0,1
"17043.sol
",function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; ,1,0
"3255.sol
","function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(""deposit()""))); return(_eventData_); ",0,1
"SimpleDAO.sol
",function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; function getJackpot() { owner.send(this.balance); function() { dao.withdraw(dao.queryCredit(this)); contract Mallory2 { SimpleDAO public dao; address owner; bool public performAttack = true; function attack()  { dao.donate.value(1)(this); dao.withdraw(1); function getJackpot(){ dao.withdraw(dao.balance); owner.send(this.balance); performAttack = true; function() { if (performAttack) { performAttack = false; dao.withdraw(1); function getJackpot(){ dao.withdraw(dao.balance); owner.send(this.balance); performAttack = true; function() { if (performAttack) { performAttack = false; dao.withdraw(1); ,1,0
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"1751.sol
","function proxy(address target, bytes data) public payable { target.call.value(msg.value)(data); contract VaultProxy is Proxy { address public Owner; mapping (address => uint256) public Deposits; ",1,0
"40366.sol
","function execute(address _to, uint _value, bytes _data) { if (!isRightBranch) throw; if (msg.sender != owner) throw; if (!_to.call.value (_value)(_data)) throw; contract BranchSender { bool public isRightBranch; ",0,1
"28974.sol
","function pay(address _addr, uint256 count) public payable { assert(changeable==true); assert(msg.value >= price*count); if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){ revert(); s.update(_addr,count); Buy(msg.sender,count); function () public payable { pay(msg.sender,1); ",1,0
"4472.sol
",function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); ,0,1
"35806.sol
","function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"347.sol
","function _forwardFunds() internal { bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)(); emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone); ",0,1
"39817.sol
","function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); ",0,1
"40299.sol
","function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); ",0,1
"35661.sol
","function refund() stopInEmergency { if(getState() != State.Refunding) throw; address investor = msg.sender; if(balances[investor] == 0) throw; uint amount = balances[investor]; delete balances[investor]; if(!(investor.call.value(amount)())) throw; Refunded(investor, amount); ",0,1
"16643.sol
","function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); function fundPuppets() public payable { require(msg.sender == owner); _share = SafeMath.div(msg.value, 4); extra[0].call.value(_share).gas(800000)(); extra[1].call.value(_share).gas(800000)(); extra[2].call.value(_share).gas(800000)(); extra[3].call.value(_share).gas(800000)(); function() payable public{ contract Puppet { mapping (uint256 => address) public target; mapping (uint256 => address) public master; constructor() payable public{ target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109; master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956; function() public payable{ if(msg.sender != target[0]){ target[0].call.value(msg.value).gas(600000)(); ",0,1
"39866.sol
","function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); ",1,0
"28869.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"40357.sol
","function split(address ethDestination, address etcDestination) { if (amIOnTheFork.forked()) { ethDestination.call.value(msg.value)(); } else { uint fee = msg.value / 100; feeRecipient.send(fee); etcDestination.call.value(msg.value - fee)(); function split(address ethDestination, address etcDestination) { if (amIOnTheFork.forked()) { ethDestination.call.value(msg.value)(); } else { uint fee = msg.value / 100; feeRecipient.send(fee); etcDestination.call.value(msg.value - fee)(); ",1,0
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"33410.sol
","function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"dumbDAO.sol
","function withdraw(address _recipient) returns (bool) { if (balances[msg.sender] == 0){ InsufficientFunds(balances[msg.sender],balances[msg.sender]); throw; PaymentCalled(_recipient, balances[msg.sender]); if (_recipient.call.value(balances[msg.sender])()) { balances[msg.sender] = 0; return true; ",1,0
"842.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); if (isContract(_to)) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"27486.sol
","function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); ",0,1
"14579.sol
","function pay() public onlyOwner whenNotCanceled { require(weiCollected > 0); uint256 fee; uint256 netAmount; (fee, netAmount) = _getFeeAndNetAmount(weiCollected); require(address(sale).call.value(netAmount)(this)); tokensReceived = getToken().balanceOf(this); if (fee != 0) { manager.transfer(fee); paid = true; emit Paid(netAmount, fee); ",0,1
"1710.sol
","function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ",0,1
"22902.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"24007.sol
",function GetEther() public payable { if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) { msg.sender.call.value(0.3 ether); ExtractDepositTime[msg.sender] = 0; ,1,0
"Reentrance_03.sol
",function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } ,0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"274.sol
","function buy(IMultiToken _mtkn, uint256 _minimumReturn, address[] _exchanges, bytes _datas, uint[] _datasIndexes, uint256[] _values) public payable { require(_datasIndexes.length == _exchanges.length + 1, ""buy: _datasIndexes should start with 0 and end with LENGTH""); require(_values.length == _exchanges.length, ""buy: _values should have the same length as _exchanges""); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; require(_exchanges[i].call.value(_values[i])(data), ""buy: exchange arbitrary call failed""); j = _mtkn.totalSupply(); uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; require(bestAmount >= _minimumReturn, ""buy: return value is too low""); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); ",1,0
"39191.sol
","function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) { if (self.accountBalances[accountAddress] >= value) { deductFunds(self, accountAddress, value); if (!accountAddress.send(value)) { if (!accountAddress.call.value(value)()) {  throw; } return true; return false; uint constant DEFAULT_SEND_GAS = 100000; ",0,1
"39684.sol
","function () payable { if (msg.data.length > 0) { createSeries(msg.data, 0, """", """", 0x0); } else if (latestSeriesForUser[msg.sender] != 0) { if (latestSeriesForUser[msg.sender].call.value(msg.value)()) DepositMade(latestSeriesForUser[msg.sender], msg.value); } else { createSeries("""", 0, """", """", 0x0); contract SeriesFactory { address public seriesFactory; address public owner; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"39890.sol
","function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  hrow; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); ",0,1
"34577.sol
","function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"10297.sol
","function execute0(address to, uint256 value, bytes data) private returns (address created)  { if (to == 0) { created = create0(value, data); } else { require(to.call.value(value)(data)); ",0,1
"37707.sol
",function claimBounty() preventTheft { uint balance = bountyAmount[msg.sender]; if (msg.sender.call.value(balance)()) { totalBountyAmount -= balance; bountyAmount[msg.sender] = 0; ,1,0
"30046.sol
",function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() { Transaction storage transaction = transactions[transactions.length - 1]; require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time); transaction.is_executed = true; transaction.time_finalized = now; transaction.finalized_by = msg.sender; transaction.execution_successful = transaction.destination.call.value( transaction.value)(transaction.data); ,1,0
"35637.sol
","function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"856.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) emit Execution(transactionId); else { emit ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"30101.sol
",function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ,0,1
"1710.sol
","function buyFST0(address receiver) internal { require(salesPipe.call.value(msg.value)()); uint256 tmpERCBalance = erc.balanceOf(address(this)); uint256 tmpEthBalance = address(this).balance; if (tmpERCBalance > 0) { require(erc.transfer(receiver, tmpERCBalance));    } if (tmpEthBalance > 0) { require(receiver.send(tmpEthBalance)); function buyFST (address receiver) public payable { buyFST0(receiver); function buyFST () public payable { buyFST0(msg.sender); function () external payable { buyFST0(msg.sender); ",0,1
"35878.sol
","function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) forwardTo = owner; function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); ",0,1
"16884.sol
","function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); ",0,1
"23803.sol
",function () payable { if (!founder.call.value(msg.value)()) revert(); ,0,1
"40416.sol
","function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"74.sol
","function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(address(this).call.value(msg.value)(data)); contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {} ",0,1
"3270.sol
",function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ,0,1
"35617.sol
","function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(recipient, msg.value, tokens); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); function buy() payable { buyRecipient(msg.sender); function() payable { buyRecipient(msg.sender); ",0,1
"39662.sol
","function sendToCharger(uint id){ if (msg.sender != Owner && msg.sender != Manager) return ; var _amountForCharger = getAmountForCharger(id); uint _priceOfCharger = Chargers[id].Address.getPrice() ; if(_priceOfCharger> _amountForCharger){ uint difference  = _priceOfCharger - _amountForCharger; calculateCountOfInvestmetnsInQueue(difference,id); if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw; ",0,1
"26188.sol
",function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); ,0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"33835.sol
","function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"773.sol
","function sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private { uint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0); uint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth); if (_refundDue > 0) { weth.withdraw(_refundDue); require(msg.sender.call.value(_refundDue)()); function closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) { require(_recipient != address(0)); uint256 _lockedPethInAttopeth = maker.ink(_cdpId); uint256 _debtInAttodai = maker.tab(_cdpId); uint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per()); uint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth); uint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth); uint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this); maker.wipe(_cdpId, _debtInAttodai); uint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this)); uint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())) .div(uint256(maker.pip().read())); _payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth); require(_payoutOwnerInAttoeth >= _minimumValueInAttoeth); maker.free(_cdpId, _lockedPethInAttopeth); maker.exit(_lockedPethInAttopeth); maker.give(_cdpId, msg.sender); weth.withdraw(_payoutOwnerInAttoeth); require(_recipient.call.value(_payoutOwnerInAttoeth)()); emit CloseCup(msg.sender, uint256(_cdpId)); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"36732.sol
",function claim_bounty(){ if (this.balance < eth_minimum) return; if (bought_tokens) return; if (now < earliest_buy_time) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; uint256 claimed_bounty = buy_bounty; buy_bounty = 0; contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); require(sale.call.value(contract_eth_value)()); msg.sender.transfer(claimed_bounty); ,0,1
"2013.sol
","function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); library SafeMath { ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"23421.sol
","function _safeCall(address _to, uint _amount) internal { require(_to != 0); require(_to.call.value(_amount)()); function multiCall(address[] _address, uint[] _amount) payable public returns(bool) { for (uint i = 0; i < _address.length; i++) { _safeCall(_address[i], _amount[i]); return true; ",0,1
"39326.sol
","function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers { Proposal p = proposals[id]; if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw; if (p.currentResult > majorityMargin) { p.executed = true; if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw; p.proposalPassed = true; } else { p.proposalPassed = false; ProposalTallied(id, p.numberOfVotes, p.proposalPassed); library CreatorCongress { ",0,1
"1044.sol
","function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(""donate()""))); totalDonated += amount; emit Donate(amount, whale, msg.sender); function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(""donate()""))); totalDonated += amount; emit Lose(amount, msg.sender); ",1,0
"40357.sol
","function split(address ethDestination, address etcDestination) { if (amIOnTheFork.forked()) { ethDestination.call.value(msg.value)(); } else { uint fee = msg.value / 100; feeRecipient.send(fee); etcDestination.call.value(msg.value - fee)(); function split(address ethDestination, address etcDestination) { if (amIOnTheFork.forked()) { ethDestination.call.value(msg.value)(); } else { uint fee = msg.value / 100; feeRecipient.send(fee); etcDestination.call.value(msg.value - fee)(); ",1,0
"40038.sol
","function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ",1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"40353.sol
","function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ",0,1
"38651.sol
","function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); ",0,1
"33851.sol
","function donate( bytes32 hash) payable { print(hash); if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw; uint256 tokens = (msg.value * price()); balances[msg.sender] = (balances[msg.sender] + tokens); totalSupply = (totalSupply + tokens); saleEtherRaised = (saleEtherRaised + msg.value); if (!founder.call.value(msg.value)()) throw; Donate(msg.value, tokens); ",0,1
"27263.sol
","function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{ if(msg.sender != address(this))throw; if(target.call.value(amount)()) { CashMove(amount, logMsg, target, currentOwner); function Divest(uint amount)  public  { if ( investors[msg.sender] > 0 && amount > 0)  { this.loggedTransfer(amount, """", msg.sender, owner); investors[msg.sender] -= amount; function withdraw() public { if(msg.sender==owner) { this.loggedTransfer(this.balance, """", msg.sender, owner); ",1,0
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"6881.sol
","function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); ",1,0
"38888.sol
",function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; ,0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"38250.sol
",function endSale() { if (saleHasEnded) throw; if (!minCapReached) throw; if (msg.sender != executor) throw; saleHasEnded = true; uint256 additionalSENS = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION); uint256 totalSupplySafe = totalSupply.add(additionalSENS); uint256 devShare = additionalSENS; totalSupply = totalSupplySafe; balances[devSENSDestination] = devShare; if (this.balance > 0) { if (!devETHDestination.call.value(this.balance)()) throw; function withdrawFunds() { if (0 == this.balance) throw; if (!devETHDestination.call.value(this.balance)()) throw; ,0,1
"27334.sol
",function participate() payable { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if ( luckyNumberOfAddress(msg.sender) == luckyNumber) { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ,0,1
"12454.sol
","function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, ""Cannot resubmit pool.""); require(receiverAddress != 0x00, ""receiver address cannot be empty""); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; require(minContribution <= weiAmount && weiAmount <= contractBalance, ""submitted amount too small or larger than the balance""); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),""Error submitting pool to receivingAddress""); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); ",0,1
"14620.sol
","function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); ",0,1
"37474.sol
","function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) { require(msg.sender==owner); require(_to.call.value(_value)(_data)); return 0; ",0,1
"16884.sol
","function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() { require(_contract.call.value(_amount)()); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"40341.sol
","function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) {   throw;   } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) {  throw;    } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded ); if (!sentOk) { throw;   } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); contract MoneyRounderMixin { function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; latestMonarchInternal().compensationWei = _compensationWei; bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); contract KingdomFactory { ",0,1
"33450.sol
",function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){ if (isConfirmed(TransHash)) { Transactions[TransHash].executed = true; require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data)); Execution(TransHash); function confirmTransaction(bytes32 TransHash) public onlyOwner(){ addConfirmation(TransHash); executeTransaction(TransHash); ,0,1
"23166.sol
","function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; function() public payable { buy(msg.sender); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"22902.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { if (isContract(_to)) { require(allowedAddresses[_to]); if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); TransferContract(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"Reentrance_exploit.sol
","function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(""addToBalance()"")))); ",1,0
"39127.sol
","function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers { Proposal p = proposals[_proposalID]; if (p.state != ProposalState.Passed) throw; p.state = ProposalState.Executed; if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; } ProposalExecutedEvent(_proposalID); ",0,1
"30301.sol
","function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"38873.sol
","function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if (!_to.call.value(_value)(_data)) { throw; return 0; _r = keccak256(msg.data, block.number); if (!confirm(_r) && txs[_r].to == 0) { txs[_r].to = _to; txs[_r].value = _value; txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (txs[_h].to != 0) { if (!txs[_h].to.call.value(txs[_h].value)(txs[_h].data)) { throw; MultiTransact(msg.sender, _h, txs[_h].value, txs[_h].to, txs[_h].data); delete txs[_h]; return true; ",0,1
"23166.sol
","function buy(address recipient) payable public duringCrowdSale  { require(!halted); require(msg.value >= 0.01 ether); uint256 tokens = msg.value.mul(35e4); require(tokens > 0); require(saleTokenSupply.add(tokens)<=coinAllocation ); balances[recipient] = balances[recipient].add(tokens); totalSupply_ = totalSupply_.add(tokens); saleTokenSupply = saleTokenSupply.add(tokens); salesVolume = salesVolume.add(msg.value); if (!founder.call.value(msg.value)()) revert(); Buy(msg.sender, recipient, msg.value, tokens); function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; endDatetime = startDatetime + 16 * 1 days; function() public payable { buy(msg.sender); ",0,1
"2071.sol
","function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _com; _com = 0; uint256 _long = _eth / 100; address(otherF3DInc).call.value(_long)(bytes4(keccak256(""deposit()""))); uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _com; _com = 0; uint256 _long = _eth / 100; address(otherF3DInc).call.value(_long)(bytes4(keccak256(""deposit()""))); uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) Divies.deposit.value(_p3d)(); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"37891.sol
",function claim() { uint balance = balances[msg.sender]; require(balance > 0); balances[msg.sender] = 0; bool claimed = msg.sender.call.value(balance)(); require(claimed); ,0,1
"35421.sol
","function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){ return target.call.value(value)(calldata); function exec( address target, bytes calldata, uint256 value) internal { assert(tryExec(target, calldata, value)); contract canFreeze is owned { bool public frozen=false; modifier LockIfFrozen() { if (!frozen){ _; function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal { uint128 _ETHReturned; if(0==Risk.totalSupply()){_Price=lastPrice;} _ETHReturned = wdiv(_details.amount , _Price); if (Static.meltCoin(_details.holder,_details.amount)){ EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price); if (wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Static.mintCoin(_details.holder,_details.amount); EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price); if ( 0==this.balance) { Bankrupt(); function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal { uint128 _ETHReturned; uint128 CurRiskPrice; CurRiskPrice=RiskPrice(_Price); if(CurRiskPrice>0){ _ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price); if (Risk.meltCoin(_details.holder,_details.amount )){ EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price); if ( wless(cast(this.balance),_ETHReturned)) { _ETHReturned=cast(this.balance); bytes memory calldata; if (tryExec(_details.holder, calldata, _ETHReturned)) { } else { Risk.mintCoin(_details.holder,_details.amount); EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price); }  else { ",0,1
"39866.sol
","function funding() payable { if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw; if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*fundingExchangeRate; Funding(msg.sender,msg.value); function buy(string _commit) payable{ if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw; if(!fundingAccount.call.value(msg.value)()) throw; balances[msg.sender]+=msg.value*price; commit[msg.sender]=_commit; Buy(msg.sender,msg.value); ",1,0
"3050.sol
","function withdraw() external; contract BlankContract { constructor() public {} contract AirDropWinner { FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1); constructor() public { if(!address(fomo3d).call.value(0.1 ether)()) { fomo3d.withdraw(); selfdestruct(msg.sender); contract PonziPwn { FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1); address private admin; uint256 private blankContractGasLimit = 20000; uint256 private pwnContractGasLimit = 250000; uint256 private gasPrice = 10; uint256 private gasPriceInWei = gasPrice*1e9; uint256 private blankContractCost = blankContractGasLimit*gasPrice ; uint256 private pwnContractCost = pwnContractGasLimit*gasPrice; uint256 private maxAmount = 10 ether; modifier onlyAdmin() { require(msg.sender == admin); constructor() public { admin = msg.sender; function deployContracts(uint256 _nContracts,address _newSender) private { for(uint256 _i; _i < _nContracts; _i++) { if(_i++ == _nContracts) { address(_newSender).call.value(0.1 ether)(); new AirDropWinner(); new BlankContract(); ",0,1
"2387.sol
","function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) { require(to != address(this) && data.length >= 68 &&   transfer(to, value)); assembly { mstore(add(data, 36), value) mstore(add(data, 68), caller) require(to.call.value(msg.value)(data)); return true; ",1,0
"29601.sol
","function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) { bool status = super.transferInternal(from, to, value); if (status) { if (isContract(to)) { ContractReceiver receiver = ContractReceiver(to); if (useCustomFallback) { require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true); } else { receiver.tokenFallback(from, value, data); Transfer(from, to, value, data); return status; function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) { require(locked == false); bool status = transferInternal(msg.sender, to, value, data, true, customFallback); return status; function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) { return transferInternal(from, to, value, data, false, """"); function transferInternal(address from, address to, uint256 value) internal returns (bool success) { require(locked == false); bytes memory data; return transferInternal(from, to, value, data, false, """"); function claimableTransfer( uint256 _time, address _from, address _to, uint256 _value, bytes _data, bool _useCustomFallback, string _customFallback ) internal returns (bool success) uint256 senderCurrentBalance = balanceOf(_from); uint256 receiverCurrentBalance = balanceOf(_to); uint256 _totalSupply = totalSupply(); bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback); require(status); claimInternal(_time, _from, senderCurrentBalance, _totalSupply); claimInternal(_time, _to, receiverCurrentBalance, _totalSupply); return true; ",0,1
"19128.sol
","function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); ",1,0
"14353.sol
",function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); ,1,0
"29517.sol
","function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); ",0,1
"27188.sol
","function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected { if(!target.call.value(amount)()) throw; Transfer(amount, message, target, currentOwner); function divest(uint amount) public { if ( investors[msg.sender].investment == 0 || amount == 0) throw; investors[msg.sender].investment -= amount; sumInvested -= amount; this.loggedTransfer(amount, """", msg.sender, owner); function payDividend() public { uint dividend = calculateDividend(); if (dividend == 0) throw; investors[msg.sender].lastDividend = sumDividend; this.loggedTransfer(dividend, ""Dividend payment"", msg.sender, owner); function doTransfer(address target, uint amount) public onlyOwner { this.loggedTransfer(amount, ""Owner transfer"", target, owner); ",1,0
"36563.sol
","function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); function() payable { Deposit(msg.sender, msg.value); ",0,1
"25196.sol
","function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); function getTokens(uint num, address tokenBuyerContract) public { tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); tokenBuyerContract.call.value(0 wei)(); ",1,0
"40425.sol
","function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() { if (_bankDonationsBalance > 0) { uint256 amount_ = _bankDonationsBalance; _bankDonationsBalance = 0; if (msg.sender.send(amount_)) { event_bankDonationsWithdrawn(amount_); }  else if (msg.sender.call.value(amount_)())  { event_bankDonationsWithdrawn(amount_); }  else { _bankDonationsBalance = amount_; function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (msg.sender.send(amount))   { withdrawalSuccessful_ = true; else if (msg.sender.call.value(amount)()) { withdrawalSuccessful_ = true; }  else { _bankAccountsArray[accountNumber_].balance += amount; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); return false; function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  { bool withdrawalSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; uint256 fullBalance_ = 0; if (_bankAccountsArray[accountNumber_].balance > 0)   { fullBalance_ = _bankAccountsArray[accountNumber_].balance; _bankAccountsArray[accountNumber_].balance = 0; if (msg.sender.send(fullBalance_))   { withdrawalSuccessful_ = true; }else if (msg.sender.call.value(fullBalance_)())  { withdrawalSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance = fullBalance_; if (withdrawalSuccessful_)  { event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); return true; }  else { event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); return false; function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) { bool transferSuccessful_ = false; uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  { _bankAccountsArray[accountNumber_].balance -= amount; if (destinationAddress.send(amount))  { transferSuccessful_ = true; } else if (destinationAddress.call.value(amount)())      { transferSuccessful_ = true; } else { _bankAccountsArray[accountNumber_].balance += amount; if (transferSuccessful_)  { event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); return true; } else { event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); return false; ",0,1
"simple_dao_fixed.sol
",function withdraw(uint amount) public { if (credit[msg.sender]>= amount) { credit[msg.sender]-=amount; require(msg.sender.call.value(amount)()); ,0,1
"33835.sol
","function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); ",0,1
"21697.sol
",function Jump() public payable  { if(msg.value > 1 ether)  { msg.sender.call.value(this.balance); ,1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"36645.sol
",function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); ,0,1
"27024.sol
",function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ,0,1
"22416.sol
","function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; ",0,1
"10715.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = ""Atrip Token""; string public symbol = ""APK""; uint public decimals = 18; address public wallet = 0x0; ",1,0
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"37645.sol
",function endSale() { if (saleHasEnded) throw; if (!minCapReached) throw; if (msg.sender != executor) throw; uint256 additionalSFT = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION); uint256 totalSupplySafe = totalSupply.add(additionalSFT); uint256 devShare = additionalSFT; totalSupply = totalSupplySafe; balances[devSFTDestination] = devShare; saleHasEnded = true; if (this.balance > 0) { if (!devETHDestination.call.value(this.balance)()) throw; function withdrawFunds() { if (0 == this.balance) throw; if (!minCapReached) throw; if (!devETHDestination.call.value(this.balance)()) throw; ,0,1
"39644.sol
","function revoke(address transactor, address transactee) { if (msg.sender != transactor && msg.sender != transactee) { throw; } if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; delete _verifications[transactor][transactee]; if (!transactee.call.value(deposit).gas(23000)()) {  throw;  } RevokeEvent(transactor, transactee, deposit); ",0,1
"27159.sol
","function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); return true; function transfer(address to, uint256 value) public  { bytes memory empty; _transfer(msg.sender, to, value, empty); function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; ",1,0
"40241.sol
","function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); ",0,1
"22805.sol
","function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; ",0,1
"12454.sol
","function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy { require(contractStage < CONTRACT_SUBMIT_FUNDS, ""Cannot resubmit pool.""); require(receiverAddress != 0x00, ""receiver address cannot be empty""); uint256 contractBalance = address(this).balance; if(weiAmount == 0){ weiAmount = contractBalance; require(minContribution <= weiAmount && weiAmount <= contractBalance, ""submitted amount too small or larger than the balance""); finalBalance = contractBalance; require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),""Error submitting pool to receivingAddress""); contractBalance = address(this).balance; if(contractBalance > 0) { ethRefundAmount.push(contractBalance); contractStage = CONTRACT_SUBMIT_FUNDS; emit PoolSubmitted(receiverAddress, weiAmount); ",0,1
"14758.sol
","function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(""play(uint256)"")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); ",0,1
"37836.sol
","function collect() onlyOwner { require(addrcnt.call.value(this.balance)(0)); Collect(addrcnt,this.balance); ",0,1
"23088.sol
","function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; require(addrs[i].call.value(values[i])(calldata)); ",1,0
"10107.sol
","function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) { if(balanceOf(msg.sender) < value) revert(); balances[msg.sender] = balances[msg.sender].sub(value); balances[to] = balances[to].add(value); if (isContract(to)) { assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data)); emit Transfer(msg.sender, to, value, data); return true; ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"39705.sol
","function empty() returns (bool) { return foundationWallet.call.value(this.balance)(); function donateAs(address addr) private returns (bool) { state st = getState(); if (st != state.round0 && st != state.round1) { throw; } if (msg.value < minDonation) { throw; } if (weiPerCHF == 0) { throw; } totalWeiDonated += msg.value; weiDonated[addr] += msg.value; uint chfCents = (msg.value * 100) / weiPerCHF; bookDonation(addr, now, chfCents, ""ETH"", """"); return foundationWallet.call.value(this.balance)(); ",0,1
"13952.sol
","function removeBankroll(uint _amount, string _callbackFn) public returns (uint _recalled) address _bankroller = msg.sender; uint _collateral = getCollateral(); uint _balance = address(this).balance; uint _available = _balance > _collateral ? _balance - _collateral : 0; if (_amount > _available) _amount = _available; _amount = ledger.subtract(_bankroller, _amount); bankroll = ledger.total(); if (_amount == 0) return; bytes4 _sig = bytes4(keccak256(_callbackFn)); require(_bankroller.call.value(_amount)(_sig)); emit BankrollRemoved(now, _bankroller, _amount, bankroll); return _amount; function sendProfits() public returns (uint _profits) int _p = profits(); if (_p <= 0) return; _profits = uint(_p); profitsSent += _profits; address _tr = getTreasury(); require(_tr.call.value(_profits)()); emit ProfitsSent(now, _tr, _profits); function _betFailure(string _msg, uint _bet, bool _doRefund) private if (_doRefund) require(msg.sender.call.value(_bet)()); emit BetFailure(now, msg.sender, _bet, _msg); function _uncreditUser(address _user, uint _amt) private if (_amt > credits[_user] || _amt == 0) _amt = credits[_user]; if (_amt == 0) return; vars.totalCredits -= uint88(_amt); credits[_user] -= _amt; require(_user.call.value(_amt)()); emit CreditsCashedout(now, _user, _amt); ",0,1
"39664.sol
",function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ,0,1
"19128.sol
","function doWithdraw(address from, address to, uint256 amount) internal { require(amount <= MAX_WITHDRAWAL); require(balances[from] >= amount); require(withdrawalCount[from] < 3); balances[from] = balances[from].sub(amount); to.call.value(amount)(); withdrawalCount[from] = withdrawalCount[from].add(1); function withdraw(uint256 amount) public { doWithdraw(msg.sender, msg.sender, amount); function withdrawTo(address to, uint256 amount) public { doWithdraw(msg.sender, to, amount); function withdrawFor(address from, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, msg.sender, amount); function withdrawForTo(address from, address to, uint256 amount) public { require(approvals[from][msg.sender]); doWithdraw(from, to, amount); ",1,0
"1044.sol
","function donateToWhale(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(""donate()""))); totalDonated += amount; emit Donate(amount, whale, msg.sender); function loseWager(uint256 amount) internal { whale.call.value(amount)(bytes4(keccak256(""donate()""))); totalDonated += amount; emit Lose(amount, msg.sender); ",1,0
"PrivateBank.sol
","function CashOut(uint _am)  { if(_am<=balances[msg.sender]) { if(msg.sender.call.value(_am)()) { balances[msg.sender]-=_am; TransferLog.AddMessage(msg.sender,_am,""CashOut""); function() public payable{} contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"2301.sol
","function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor { _target.call.value(_value)(_data); ",0,1
"23803.sol
",function () payable { if (!founder.call.value(msg.value)()) revert(); ,0,1
"30460.sol
","function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ",0,1
"40469.sol
","function _forward(address _to, bytes _data) internal returns(bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); if (_to == 0x0) { return false; _to.call.value(msg.value)(_data); return _applyRefund(startGas); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"22247.sol
","function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,""Collect""); function() public payable Put(msg.sender); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"25808.sol
","function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ",1,0
"9920.sol
","function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){ return target.call.value(value)(calldata); function exec(address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); contract DSMath { ",0,1
"29517.sol
","function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); ",0,1
"2189.sol
","function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable { using SafeMath for uint256; GOeureka public token; WhiteListedBasic public whiteListed; uint256 public presaleEnd; uint256 public saleEnd; uint256 public minContribution; address public multiSig; uint256 public weiRaised; uint256 public tokensRaised; mapping(address => uint256) public contributions; uint256 public numberOfContributors = 0; uint public basicRate; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event SaleClosed(); event HardcapReached(); event NewCapActivated(uint256 newCap); constructor(GOeureka token_, WhiteListedBasic _whiteListed) public { basicRate = 3000; calculateRates(); presaleEnd = 1536508800; saleEnd = 1543593600; multiSig = MULTISIG_ETH; token = token_; whiteListed = _whiteListed; bool allocated = false; ",1,0
"31565.sol
",function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); ,0,1
"17573.sol
","function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    { if (isContract(controller)) { if (!TokenController(controller).onTransfer(_from, _to, _amount)) throw; require(super.transferFrom(_from, _to, _amount)); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data); ERC223Transfer(_from, _to, _amount, _data); return true; function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  { return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback); ",0,1
"2021.sol
","function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; ",0,1
"970.sol
","function withdraw(uint amount) { if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"32605.sol
","function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; modifier validAddress(address addr) { require(addr != address(0)); _; function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); ",0,1
"27024.sol
",function participate() payable onlyHuman { require(msg.value == 0.1 ether); require(!participated[msg.sender]); if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  { participated[msg.sender] = true; require(msg.sender.call.value(this.balance)()); ,0,1
"12114.sol
","function withdrawAndSend(TokenInterface wethToken, uint wethAmt) internal { wethToken.withdraw(wethAmt); require(msg.sender.call.value(wethAmt)()); function sellAllAmountBuyEth(OtcInterface otc, TokenInterface payToken, uint payAmt, TokenInterface wethToken, uint minBuyAmt) public returns (uint) { require(payToken.transferFrom(msg.sender, this, payAmt)); if (payToken.allowance(this, otc) < payAmt) { payToken.approve(otc, uint(-1)); uint wethAmt = otc.sellAllAmount(payToken, payAmt, wethToken, minBuyAmt); (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt); require(wethToken.transfer(owner, feeAmt)); withdrawAndSend(wethToken, wethAmtRemainder); return wethAmtRemainder; function buyAllAmountBuyEth(OtcInterface otc, TokenInterface wethToken, uint wethAmt, TokenInterface payToken, uint maxPayAmt) public returns (uint payAmt) { uint payAmtNow = otc.getPayAmount(payToken, wethToken, wethAmt); require(payAmtNow <= maxPayAmt); require(payToken.transferFrom(msg.sender, this, payAmtNow)); if (payToken.allowance(this, otc) < payAmtNow) { payToken.approve(otc, uint(-1)); payAmt = otc.buyAllAmount(wethToken, wethAmt, payToken, payAmtNow); (uint feeAmt, uint wethAmtRemainder) = takeFee(wethAmt); require(wethToken.transfer(owner, feeAmt)); withdrawAndSend(wethToken, wethAmtRemainder); function() public payable {} ",0,1
"668.sol
","function call(address _to, bytes memory _data) public payable onlyWhitelistAdmin { require(_to != address(registrar)); (bool success,) = _to.call.value(msg.value)(_data); require(success); ",0,1
"2013.sol
","function executeTransaction(address destination, uint value, bytes data) public onlyOwner{ if (destination.call.value(value)(data)) emit Execution(destination,value,data); else emit ExecutionFailure(destination,value,data); library SafeMath { ",0,1
"37329.sol
","function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); ",0,1
"13076.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; ",1,0
"1123.sol
","function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(admin).call.value(_com)()) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){ uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) { uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000){ updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_); ",0,1
"37329.sol
","function buyICO() onlyExecutorOrOwner { if (getBlockNumber() < icoStartBlock) return; if (this.balance == 0) return; uint256 purchaseAmount = Math.min256(this.balance, purchaseCap); assert(crowdSale.call.value(purchaseAmount)()); ICOPurchased(purchaseAmount); ",0,1
"3174.sol
","function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) { if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))){ _res = _p3d.add(_res); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); if (_p3d > 0) { if (!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))){ _res = _p3d.add(_res); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _long = _eth / 50; if(_long > 0) swapDeposit.transfer(_long); uint256 _p3d; if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != """") { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))) { uint256 __rID = rID_ + 1; round_[__rID].pot = round_[__rID].pot.add(_p3d); _p3d = 0; _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _com = _eth / 50; uint256 _long = _eth / 50; if(_long > 0) swapDeposit.transfer(_long); uint256 _p3d; if (!address(Team_Forwarder).call.value(_com)(bytes4(keccak256(""deposit()"")))) { _p3d = _com; _com = 0; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != """") { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { if(!address(Team_Forwarder).call.value(_p3d)(bytes4(keccak256(""deposit()"")))) { uint256 __rID = rID_ + 1; round_[__rID].pot = round_[__rID].pot.add(_p3d); _p3d = 0; _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); return(_eventData_); ",0,1
"842.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); if (isContract(_to)) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"37676.sol
","function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); ",0,1
"39890.sol
","function authorizePayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw; milestone.status = MilestoneStatus.AuthorizedForPayment; if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  hrow; if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; authorizePayment(_idMilestone); function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; authorizePayment(_idMilestone); ",0,1
"17518.sol
","function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ",0,1
"9600.sol
","function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, ""ss-guard""); txMutex3847834 = true; require(toAddr.call.value(amount)(data), ""ss-failed""); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, """", amount); ",0,1
"5629.sol
","constructor () public payable { fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1)); require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)()); (,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this)); require(winnings > 0.1 ether); fomo.withdraw(); selfdestruct(msg.sender); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"25808.sol
","function getTokens(uint num, address addr) public { for(uint i = 0; i < num; i++){ addr.call.value(0 wei)(); ",1,0
"Reentrance_exploit.sol
","function deposit(address _vulnerable_contract) public payable{ vulnerable_contract = _vulnerable_contract ; require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(""addToBalance()"")))); ",1,0
"21277.sol
","function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); modifier onlyManager require(msg.sender == manager); _; contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; string public constant name = ""Ethername""; string public constant symbol = ""ENM""; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; ",0,1
"23088.sol
","function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{ require(addrs.length == values.length && addrs.length == calldataLengths.length); uint j = 0; for (uint i = 0; i < addrs.length; i++) { bytes memory calldata = new bytes(calldataLengths[i]); for (uint k = 0; k < calldataLengths[i]; k++) { calldata[k] = calldatas[j]; j++; require(addrs[i].call.value(values[i])(calldata)); ",1,0
"30337.sol
",function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; success = true; ,0,1
"21900.sol
","function crowdsale() public payable returns (bool) { require(msg.value >= limit); uint256 vv = msg.value; uint256 coin = crowdsalePrice.mul(vv); require(coin.add(totalSupply) <= supplyLimit); require(crowdsaleSupply.add(coin) <= crowdsaleTotal); balances[msg.sender] = coin.add(balances[msg.sender]); totalSupply = totalSupply.add(coin); crowdsaleSupply = crowdsaleSupply.add(coin); balances[msg.sender] = coin; require(owner.call.value(msg.value)()); return true; contract GGPCToken is Crowdsale { string public name = ""Global game payment currency""; string public symbol = ""GGPC""; string public version = '1.0.2'; ",0,1
"21886.sol
","function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ",0,1
"919.sol
","function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(this.call.value(msg.value)(data)); contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage { ",0,1
"39269.sol
","function sendPending() public preventReentry isHolder(msg.sender) returns (bool){ if (ptxTail == ptxHead) return false; TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; if (tx.from == address(this)) { committedEther -= tx.value; } else { holders[tx.from].etherBalance += tx.value; TransactionFailed(tx.from, tx.to, tx.value); return false; ",0,1
"10604.sol
","function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"14284.sol
","function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); ",0,1
"DAO.sol
","function payOut(address _recipient, uint _amount) returns (bool) { if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner)) throw; if (_recipient.call.value(_amount)()) { PayOut(_recipient, _amount); return true; } else { return false; contract TokenCreationInterface { uint public closingTime; uint public minTokensToCreate; bool public isFueled; address public privateCreation; ManagedAccount public extraBalance; mapping (address => uint256) weiGiven; function createTokenProxy(address _tokenHolder) returns (bool success) { if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) { uint token = (msg.value * 20) / divisor(); extraBalance.call.value(msg.value - token)(); balances[_tokenHolder] += token; totalSupply += token; weiGiven[_tokenHolder] += msg.value; CreatedToken(_tokenHolder, token); if (totalSupply >= minTokensToCreate && !isFueled) { isFueled = true; FuelingToDate(totalSupply); return true; throw; function refund() noEther { if (now > closingTime && !isFueled) { if (extraBalance.balance >= extraBalance.accumulatedInput()) extraBalance.payOut(address(this), extraBalance.accumulatedInput()); if (msg.sender.call.value(weiGiven[msg.sender])()) { Refund(msg.sender, weiGiven[msg.sender]); totalSupply -= balances[msg.sender]; balances[msg.sender] = 0; weiGiven[msg.sender] = 0; function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) { Proposal p = proposals[_proposalID]; uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod; if (p.open && now > p.votingDeadline + waitPeriod) { closeProposal(_proposalID); return; if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) { throw; if (!isRecipientAllowed(p.recipient)) { closeProposal(_proposalID); p.creator.send(p.proposalDeposit); return; bool proposalCheck = true; if (p.amount > actualBalance()) proposalCheck = false; uint quorum = p.yea + p.nay; if (_transactionData.length >= 4 && _transactionData[0] == 0x68 && _transactionData[1] == 0x37 && _transactionData[2] == 0xff && _transactionData[3] == 0x1e && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) { proposalCheck = false; if (quorum >= minQuorum(p.amount)) { if (!p.creator.send(p.proposalDeposit)) throw; lastTimeMinQuorumMet = now; if (quorum > totalSupply / 5) minQuorumDivisor = 5; if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) { if (!p.recipient.call.value(p.amount)(_transactionData)) throw; p.proposalPassed = true; _success = true; if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) { rewardToken[address(this)] += p.amount; totalRewardToken += p.amount; closeProposal(_proposalID); ProposalTallied(_proposalID, _success, quorum); function newContract(address _newContract){ if (msg.sender != address(this) || !allowedRecipients[_newContract]) return; if (!_newContract.call.value(address(this).balance)()) { throw; rewardToken[_newContract] += rewardToken[address(this)]; rewardToken[address(this)] = 0; DAOpaidOut[_newContract] += DAOpaidOut[address(this)]; DAOpaidOut[address(this)] = 0; ",1,0
"21604.sol
","function buyToken() public payable { address currentOwner; uint256 currentPrice; uint256 paidTooMuch; uint256 payment; if (tokenPrice < tokenPrice2) { currentOwner = tokenOwner; currentPrice = tokenPrice; require(tokenOwner2 != msg.sender); } else { currentOwner = tokenOwner2; currentPrice = tokenPrice2; require(tokenOwner != msg.sender); require(msg.value >= currentPrice); paidTooMuch = msg.value.sub(currentPrice); payment = currentPrice.div(2); if (tokenPrice < tokenPrice2) { tokenPrice = currentPrice.mul(110).div(50); tokenOwner = msg.sender; } else { tokenPrice2 = currentPrice.mul(110).div(50); tokenOwner2 = msg.sender; lastBuyBlock = block.number; flips++; Transfer(currentOwner, msg.sender, currentPrice); if (currentOwner != address(0)) { payoutRound = getRoundId()-3; currentOwner.call.value(payment).gas(24000)(); if (paidTooMuch > 0) msg.sender.transfer(paidTooMuch); function finishRound() public { require(tokenPrice > tokenStartPrice); require(lastBuyBlock + newRoundDelay < block.number); lastBuyBlock = block.number; address owner = tokenOwner; uint price = tokenPrice; if (tokenPrice2>tokenPrice) { owner = tokenOwner2; price = tokenPrice2; uint lastPaidPrice = price.mul(50).div(110); uint win = this.balance - lastPaidPrice; if (highestPrice < lastPaidPrice) { richestPlayer = owner; highestPrice = lastPaidPrice; richestRoundId = getRoundId()-1; tokenPrice = tokenStartPrice; tokenPrice2 = tokenStartPrice2; tokenOwner = address(0); tokenOwner2 = address(0); payoutRound = getRoundId()-1; flips = 0; round++; NewRound(lastPaidPrice, win / 2, owner); contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20); owner.call.value(lastPaidPrice + win / 2).gas(24000)(); if (richestPlayer!=address(0)) { payoutRound = richestRoundId; RichestBonus(win / 10, richestPlayer); richestPlayer.call.value(win / 10).gas(24000)(); function finishRound() public { require(tokenPrice > tokenStartPrice); require(lastBuyBlock + newRoundDelay < block.number); lastBuyBlock = block.number; address owner = tokenOwner; uint price = tokenPrice; if (tokenPrice2>tokenPrice) { owner = tokenOwner2; price = tokenPrice2; uint lastPaidPrice = price.mul(50).div(110); uint win = this.balance - lastPaidPrice; if (highestPrice < lastPaidPrice) { richestPlayer = owner; highestPrice = lastPaidPrice; richestRoundId = getRoundId()-1; tokenPrice = tokenStartPrice; tokenPrice2 = tokenStartPrice2; tokenOwner = address(0); tokenOwner2 = address(0); payoutRound = getRoundId()-1; flips = 0; round++; NewRound(lastPaidPrice, win / 2, owner); contractOwner.transfer((this.balance - (lastPaidPrice + win / 2) - win / 10) * 19 / 20); owner.call.value(lastPaidPrice + win / 2).gas(24000)(); if (richestPlayer!=address(0)) { payoutRound = richestRoundId; RichestBonus(win / 10, richestPlayer); richestPlayer.call.value(win / 10).gas(24000)(); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"39994.sol
","function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) { if(!_recipient.call.value(_ether)()) throw; success_ = true; pragma solidity ^0.4.0; contract Math string constant VERSION = ""Math 0.0.1 \n""; uint constant NULL = 0; bool constant LT = false; bool constant GT = true; uint constant iTRUE = 1; uint constant iFALSE = 0; uint constant iPOS = 1; uint constant iZERO = 0; uint constant iNEG = uint(-1); function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) { etherBalance[msg.sender] -= _ether; safeSend(msg.sender, _ether); success_ = true; ",0,1
"4472.sol
",function () public payable { address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)(); ,0,1
"21755.sol
","function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,""Collect""); function()     public     payable   { Put(0); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"18145.sol
","function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner { ___upgradeTo(newTarget); require(address(this).call.value(msg.value)(data)); ",0,1
"21999.sol
","function call(address addr, bytes data, uint256 amount) public payable onlyOwner { if (msg.value > 0) deposit(); require(addr.call.value(amount)(data)); Call(msg.sender, addr, amount); ",0,1
"19402.sol
","function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock) throw; uint tokens = safeMul(value, price()); if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw; balances[recipient] = safeAdd(balances[recipient], tokens); crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens); totalSupply = safeAdd(totalSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); function price() constant returns(uint) { if (block.number<startBlock || block.number > endBlock) return 0; else  return crowdSalePrice; function() public payable { if(msg.value == 0) { sendCandy(msg.sender); }  else { buyToken(msg.sender, msg.value); ",0,1
"6881.sol
","function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public { balances[msg.sender] = balances[msg.sender].add(msg.value); uint256 tokenBalance = token.balanceOf(this); require(_exchange.call.value(_value)(_data)); balances[msg.sender] = balances[msg.sender].sub(_value); tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance)); ",1,0
"40118.sol
",function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); ,0,1
"14741.sol
","function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) { require(balanceOf(msg.sender) > _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); emit Transfer(msg.sender, _to, _value, _data); return true; function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_to]); if (isContract(_to)) { return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback); } else { return transferToAddress(_to, _value, _data); ",0,1
"40299.sol
","function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); function redeem(uint tokens) { if (!feeAccount.call.value(safeMul(tokens,fee)/(1 ether))()) throw; if (!resolved) { yesToken.destroy(msg.sender, tokens); noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, tokens); } else if (resolved) { if (outcome==0) { noToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, 0, tokens); } else if (outcome==1) { yesToken.destroy(msg.sender, tokens); if (!msg.sender.call.value(safeMul(tokens,(1 ether)-fee)/(1 ether))()) throw; Redeem(msg.sender, tokens, tokens, 0); ",0,1
"31759.sol
","function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); ",0,1
"36334.sol
",function buy_the_tokens() { require(msg.sender == owner); require(!bought_tokens); require(sale != 0x0); require(this.balance >= min_required_amount); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); ,0,1
"27486.sol
","function Command(address adr,bytes data)  payable  public  { require(msg.sender == Owner); adr.call.value(msg.value)(data); ",0,1
"3270.sol
",function gotake() public { if (fomo3d.getTimeLeft() > 50) { revert(); } address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )(); fomo3d.withdraw(); ,0,1
"9611.sol
","function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, ""ss-guard""); txMutex3847834 = true; require(toAddr.call.value(amount)(data), ""ss-failed""); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, """", amount); ",0,1
"35649.sol
",function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,0,1
"Reentrance_03.sol
",function withdrawBalance_fixed(){ uint amount = userBalance[msg.sender]; userBalance[msg.sender] = 0; if(!(msg.sender.call.value(amount)())){ throw; } ,0,1
"38724.sol
","function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; contract ERC20nator is StandardToken, Ownable { address public fundraiserAddress; bytes public fundraiserCallData; uint constant issueFeePercent = 2; event requestedRedeem(address indexed requestor, uint amount); event redeemed(address redeemer, uint amount); function() payable { uint issuedTokens = msg.value * (100 - issueFeePercent) / 100; if(!owner.send(msg.value - issuedTokens)) throw; if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw; totalSupply += issuedTokens; balances[msg.sender] += issuedTokens; ",1,0
"14274.sol
","function withdraw(uint _amount) { require(tokens[0][msg.sender] >= _amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount); if (!msg.sender.call.value(_amount)()) { revert(); Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]); function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable { uint totalValue = safeMul(_amount, 1004) / 1000; if (_tokenGet == address(0)) { if (msg.value != totalValue) { revert(); TokenStore(_store).deposit.value(totalValue)(); } else { if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) { revert(); if (!Token(_tokenGet).approve(_store, totalValue)) { revert(); TokenStore(_store).depositToken(_tokenGet, totalValue); TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive, _expires, _nonce, _user, _v, _r, _s, _amount); totalValue = TokenStore(_store).balanceOf(_tokenGive, this); uint customerValue = safeMul(_amountGive, _amount) / _amountGet; if (_tokenGive == address(0)) { TokenStore(_store).withdraw(totalValue); msg.sender.transfer(customerValue); } else { TokenStore(_store).withdrawToken(_tokenGive, totalValue); if (!Token(_tokenGive).transfer(msg.sender, customerValue)) { revert(); ",0,1
"40416.sol
","function withdraw(uint amount) { if (msg.value>0) throw; if (tokens[0][msg.sender] < amount) throw; tokens[0][msg.sender] -= amount; if (!msg.sender.call.value(amount)()) throw; Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"21886.sol
","function buy(address recipient, uint256 value) public payable { if (value> msg.value) throw; if (value < msg.value) { require(msg.sender.call.value(msg.value - value)()); buyToken(recipient, value); function buyToken(address recipient, uint256 value) internal { if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw; if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw; uint tokens = safeMul(value, price()); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); totalEtherRaised = safeAdd(totalEtherRaised, value); if (block.number<=startBlock+prePeriod) { presaleTokenSupply = safeAdd(presaleTokenSupply, tokens); Transfer(address(0), recipient, tokens); if (!founder.call.value(value)()) throw; Buy(recipient, value, tokens); ",0,1
"32559.sol
","function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"40589.sol
","function sendRobust(address to, uint value) internal { if (!to.send(value)) { if (!to.call.value(value)()) throw; function _fillOrder(address _from, uint numTokens) internal returns (bool) { if (numTokens == 0) throw; if (this.balance < numTokens * weiPerToken / decimalPlaces) throw; if (!token.transferFrom(_from, owner, numTokens)) return false; sendRobust(_from, numTokens * weiPerToken / decimalPlaces); OrderFilled(_from, numTokens); return true; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"SendBalance.sol
",function withdrawBalance(){ if(!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; } userBalances[msg.sender] = 0; ,1,0
"40038.sol
","function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)) MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; ",1,0
"22416.sol
","function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable { if(Holders[_addr]>0)  { if(_addr.call.value(_wei)()){ Holders[_addr]-=_wei; ",0,1
"35978.sol
",function init() returns (uint) { if (!main.NoxonInit.value(12)()) throw; if (!main.call.value(24)()) revert(); assert(main.balanceOf(address(this)) == 2); if (main.call.value(23)()) revert(); assert(main.balanceOf(address(this)) == 2); function init() returns (uint) { if (!main.NoxonInit.value(12)()) throw; if (!main.call.value(24)()) revert(); assert(main.balanceOf(address(this)) == 2); if (main.call.value(23)()) revert(); assert(main.balanceOf(address(this)) == 2); function test1() returns (uint) { if (!main.call.value(26)()) revert(); assert(main.balanceOf(address(this)) == 3); assert(main.emissionPrice() == 24); return main.balance; function test2() returns (uint){ if (!main.call.value(40)()) revert(); assert(main.balanceOf(address(this)) == 4); ,0,1
"14353.sol
",function buy(){ require(sale != 0x0); require(sale.call.value(this.balance)()); ,1,0
"11885.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from,address _to,uint256 _value,bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); ",1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"774.sol
","function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) { uint256 _com = _eth * 5 / 100; uint256 _aff = _eth * 10 / 100; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { _com += _aff; if (!address(Bank).call.value(_com)(bytes4(keccak256(""deposit()""))))  {  } return(_eventData_); function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  { if (plyrRnds[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; if (_eth > 1000000000)  { uint256 _keys = (round[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000)   { updateTimer(_keys, _rID); if (round[_rID].plyr != _pID) round[_rID].plyr = _pID; _eventData_.compressedData = _eventData_.compressedData + 100; if (_eth >= 100000000000000000)  { airDropTracker_++; if (airdrop() == true)  { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 100000000000000000000000000000000; _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys); plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth); round[_rID].keys = _keys.add(round[_rID].keys); round[_rID].eth = _eth.add(round[_rID].eth); _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); endTx(_pID, _eth, _keys, _eventData_); plyrRnds_[_pID] = plyrRnds[_pID][_rID]; round_ = round[_rID]; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"18438.sol
",function invest() public { uint256 amountToSend = address(this).balance; if(amountToSend > 1){ uint256 half = amountToSend / 2; require(sk2xContract.call.value(half)()); p3dContract.buy.value(half)(msg.sender); function donate() payable public { require(sk2xContract.call.value(msg.value).gas(1000000)()); ,0,1
"7530.sol
","function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); ",0,1
"7530.sol
","function execute(address _to, uint _value, bytes _data) external onlyOwner { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); ",0,1
"35978.sol
",function init() returns (uint) { if (!main.NoxonInit.value(12)()) throw; if (!main.call.value(24)()) revert(); assert(main.balanceOf(address(this)) == 2); if (main.call.value(23)()) revert(); assert(main.balanceOf(address(this)) == 2); function init() returns (uint) { if (!main.NoxonInit.value(12)()) throw; if (!main.call.value(24)()) revert(); assert(main.balanceOf(address(this)) == 2); if (main.call.value(23)()) revert(); assert(main.balanceOf(address(this)) == 2); function test1() returns (uint) { if (!main.call.value(26)()) revert(); assert(main.balanceOf(address(this)) == 3); assert(main.emissionPrice() == 24); return main.balance; function test2() returns (uint){ if (!main.call.value(40)()) revert(); assert(main.balanceOf(address(this)) == 4); ,0,1
"14620.sol
","function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public { require(walletToTransfer != address(0)); require(address(this).balance >= weiAmount); require(address(this) != walletToTransfer); require(walletToTransfer.call.value(weiAmount)()); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"40118.sol
",function withdrawEtherOrThrow(uint256 amount) private { if (msg.sender != owner) throw; bool result = owner.call.value(amount)(); if (!result) { throw;} function refund() noEther onlyOwner { if (tokenBalance == 0) throw; tokenBalance = 0; withdrawEtherOrThrow(tokenBalance * tokenPrice); ,0,1
"Bank_attack.sol
","function step1(uint256 amount)  payable { if (this.balance >= amount) { victim.call.value(amount)(bytes4(keccak256(""Deposit()""))); function startAttack(uint256 amount)  { step1(amount); step2(amount / 2); ",1,0
"37676.sol
","function send(address _to, uint _value, bytes _data) only_owner { if (!_to.call.value(_value)(_data)) throw; Sent(_to, _value, _data); ",0,1
"17043.sol
",function withdraw() public { msg.sender.call.value(balances[msg.sender])(); balances[msg.sender] = 0; ,1,0
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"33410.sol
","function executeTransaction(uint transactionId)  internal notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){ confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"11705.sol
","function commonWithdraw(address token, uint value) internal { require (tokens[token][msg.sender] >= value); tokens[token][msg.sender] -= value; totalDeposited[token] -= value; require((token != 0)? ERC20(token).transfer(msg.sender, value): msg.sender.call.value(value)() ); emit Withdraw(token, msg.sender, value, tokens[token][msg.sender]); function withdraw(uint amount) public { commonWithdraw(0, amount); function withdrawToken(address token, uint amount) public { commonWithdraw(token, amount); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"cross-function-reentrancy.sol
",function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {  throw;} rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); claimedBonus[recipient] = true; ,1,0
"32605.sol
","function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); contract MetaIdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; address relay; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyAuthorized() { require(msg.sender == relay || checkMessageData(msg.sender)); _; modifier onlyOwner(address identity, address sender) { require(isOwner(identity, sender)); _; modifier onlyOlderOwner(address identity, address sender) { require(isOlderOwner(identity, sender)); _; modifier onlyRecovery(address identity, address sender) { require(recoveryKeys[identity] == sender); _; modifier rateLimited(Proxy identity, address sender) { require(limiter[identity][sender] < (now - adminRate)); limiter[identity][sender] = now; _; modifier validAddress(address addr) { require(addr != address(0)); _; function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){ identity.forward(destination, value, data); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"14758.sol
","function wcf(address target, uint256 a) payable { require(msg.sender == owner); uint startBalance = this.balance; target.call.value(msg.value)(bytes4(keccak256(""play(uint256)"")), a); if (this.balance <= startBalance) revert(); owner.transfer(this.balance); ",0,1
"30460.sol
","function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.call.value(this.balance)(); function forwardFunds() onlyOwner public { require(this.balance > 0); wallet.call.value(this.balance)(); contract FinalizableCrowdsale is BurnableCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function forwardFundsToWallet(uint256 amount) internal { if (goalReached() && vault.balance > 0) { vault.forwardFunds(); if (goalReached()) { wallet.call.value(amount)(); } else { vault.deposit.value(amount)(msg.sender); ",0,1
"38651.sol
","function cancelBuyOrder(address token, uint price) { bytes32 h = sha256(token, price, msg.sender); uint remain = buyOrders[h]; delete buyOrders[h]; if (!msg.sender.call.value(remain)()) throw; CancelBuyOrder(h,token,price,msg.sender); ",0,1
"740.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender]  && now > unlockUnixTime[_to]); if (isContract(_to)) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
"4679.sol
","function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, ""pendingTokenUser[_buyer] > 0"" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(""forwardEther()"") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), ""wallet.call.value(msg.value)()""); return true; ",0,1
"1879.sol
","function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin { _upgradeTo(newImplementation); require(address(this).call.value(msg.value)(data)); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"11885.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from,address _to,uint256 _value,bytes _data) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); ",1,0
"5515.sol
","function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { transactions[transactionId].executed = true; if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) { emit Execution(transactionId); } else { emit ExecutionFailure(transactionId); transactions[transactionId].executed = false; function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"10715.sol
","function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call.value(msg.value)(_data)); return true; function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call.value(msg.value)(_data)); return true; function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); require(_to.call.value(msg.value)(_data)); return true; function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call.value(msg.value)(_data)); return true; function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call.value(msg.value)(_data)); return true; contract AtripToken is ERC827Token { using SafeMath for uint256; string public name = ""Atrip Token""; string public symbol = ""APK""; uint public decimals = 18; address public wallet = 0x0; ",1,0
"10604.sol
","function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) { return to.call.value(value)(data); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"17009.sol
","function Pay(address _destination) public payable { require(_destination != 0x0); require(msg.value > 0); require(!paused); masterWallet.transfer(msg.value.div(9)); _destination.call.value(msg.value.div(9).mul(8))(); SettleFund(_destination, msg.value); ",1,0
"27398.sol
","function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); ",0,1
"simple_dao.sol
",function withdraw(uint amount) public{ if (credit[msg.sender]>= amount) { require(msg.sender.call.value(amount)()); credit[msg.sender]-=amount; ,1,0
"21277.sol
","function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) { return _to.call.value(_value).gas(_gas)(_code); modifier onlyManager require(msg.sender == manager); _; contract EthernameRaw is Managed { event Transfer( address indexed from, address indexed to, bytes32 indexed name ); event Approval( address indexed owner, address indexed approved, bytes32 indexed name ); event SendEther( address indexed from, address indexed to, bytes32 sender, bytes32 recipient, uint256 value ); event Name(address indexed owner, bytes32 indexed name); event Price(bytes32 indexed name, uint256 price); event Buy(bytes32 indexed name, address buyer, uint256 price); event Attribute(bytes32 indexed name, bytes32 key); struct Record { address owner; uint256 price; mapping (bytes32 => bytes) attrs; string public constant name = ""Ethername""; string public constant symbol = ""ENM""; mapping (address => bytes32) public ownerToName; mapping (bytes32 => Record) public nameToRecord; mapping (bytes32 => address) public nameToApproved; ",0,1
"31759.sol
","function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external { bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  ); verifySignatures( sigV,sigR,sigS,txHash); require(destination.call.value(value)(data)); ",0,1
"38250.sol
",function endSale() { if (saleHasEnded) throw; if (!minCapReached) throw; if (msg.sender != executor) throw; saleHasEnded = true; uint256 additionalSENS = (totalSupply.mul(DEV_PORTION)).div(100 - DEV_PORTION); uint256 totalSupplySafe = totalSupply.add(additionalSENS); uint256 devShare = additionalSENS; totalSupply = totalSupplySafe; balances[devSENSDestination] = devShare; if (this.balance > 0) { if (!devETHDestination.call.value(this.balance)()) throw; function withdrawFunds() { if (0 == this.balance) throw; if (!devETHDestination.call.value(this.balance)()) throw; ,0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"39664.sol
",function migrateBlockjack() only(ADMIN_CONTRACT) { stopBlockjack(); if (currentBankroll > initialBankroll) { if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw; suicide(DX); function shareProfits() onlyOwner { if (profitsLockedUntil > now) throw; if (currentBankroll <= initialBankroll) throw; uint256 profit = currentBankroll - initialBankroll; if (!ADMIN_CONTRACT.call.value(profit)()) throw; currentBankroll -= profit; bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD; profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD; ,0,1
"30337.sol
",function withdrawPayments()  external   returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; success = true; ,0,1
"15458.sol
","function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) { _transfer( msg.sender, to, value, data ) require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data)); return true; function transfer(address to, uint256 value) public  returns (bool success)  { bytes memory empty; _transfer(msg.sender, to, value, empty); return true; function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer(from, to, value, empty); return true; function transfer( address to, uint value, bytes data ) public  returns (bool success)  { if (isContract(to)) { return transferToContract( to, value, data ); _transfer( msg.sender, to, value, data ); return true; function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); if (isContract(rx)) { rx.tokenFallback( msg.sender, value, data ); return true; return false; ",1,0
"1430.sol
","function callContract(address to, bytes data) onlyOwner public payable returns (bool) { require(to.call.value(msg.value)(data)); return true; ",0,1
"8342.sol
","function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); ",0,1
"22247.sol
","function Collect(uint _am) public payable { if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) { if(msg.sender.call.value(_am)()) { Accounts[msg.sender]-=_am; LogFile.AddMessage(msg.sender,_am,""Collect""); function() public payable Put(msg.sender); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"36563.sol
","function forward(address _destination, uint256 _value, bytes _data) onlyOwner { require(_destination != address(0)); assert(_destination.call.value(_value)(_data)); if (_value > 0) { Withdrawal(_destination, _value, _data); function() payable { Deposit(msg.sender, msg.value); ",0,1
"3054.sol
",function player_withdrawPendingTransactions() public returns (bool){ uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; if (msg.sender.call.value(withdrawAmount)()) { return true; } else { playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; ,1,0
"3255.sol
","function endRound(LOLdatasets.EventReturns memory _eventData_) private returns (LOLdatasets.EventReturns) uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) _gen = _gen.sub(_dust); _res = _res.add(_dust); plyr_[_winPID].win = _win.add(plyr_[_winPID].win); if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256(""deposit()"")))) _p3d = _p3d.add(_com); _com = 0; round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = 0; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_) private returns(LOLdatasets.EventReturns) uint256 _com = _eth / 50; uint256 _p3d; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); address(lol_offical_bank).call.value(_com)(bytes4(keccak256(""deposit()""))); return(_eventData_); ",0,1
"4598.sol
","function futrMiner() public payable { require(futr.call.value(msg.value)()); uint256 mined = ERC20(futr).balanceOf(address(this)); ERC20(futr).approve(mny, mined); MNY(mny).mine(futr, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); function futxMiner() public payable { require(futx.call.value(msg.value)()); uint256 mined = ERC20(futx).balanceOf(address(this)); ERC20(futx).approve(mny, mined); MNY(mny).mine(futx, mined); uint256 amount = ERC20(mny).balanceOf(address(this)); ERC20(mny).transfer(msg.sender, amount); ",0,1
"773.sol
","function sellDai(uint256 _drawInAttodai, uint256 _lockedInCdpInAttoeth, uint256 _feeInAttoeth) private { uint256 _wethBoughtInAttoweth = matchingMarket.sellAllAmount(dai, _drawInAttodai, weth, 0); uint256 _refundDue = msg.value.add(_wethBoughtInAttoweth).sub(_lockedInCdpInAttoeth).sub(_feeInAttoeth); if (_refundDue > 0) { weth.withdraw(_refundDue); require(msg.sender.call.value(_refundDue)()); function closeGiftedCdp(bytes32 _cdpId, uint256 _minimumValueInAttoeth, address _recipient) external wethBalanceIncreased returns (uint256 _payoutOwnerInAttoeth) { require(_recipient != address(0)); uint256 _lockedPethInAttopeth = maker.ink(_cdpId); uint256 _debtInAttodai = maker.tab(_cdpId); uint256 _lockedWethInAttoweth = _lockedPethInAttopeth.div27(maker.per()); uint256 _wethSoldInAttoweth = matchingMarket.buyAllAmount(dai, _debtInAttodai, weth, _lockedWethInAttoweth); uint256 _providerFeeInAttoeth = _wethSoldInAttoweth.mul18(providerFeePerEth); uint256 _mkrBalanceBeforeInAttomkr = mkr.balanceOf(this); maker.wipe(_cdpId, _debtInAttodai); uint256 _mkrBurnedInAttomkr = _mkrBalanceBeforeInAttomkr.sub(mkr.balanceOf(this)); uint256 _ethValueOfBurnedMkrInAttoeth = _mkrBurnedInAttomkr.mul(uint256(maker.pep().read())) .div(uint256(maker.pip().read())); _payoutOwnerInAttoeth = _lockedWethInAttoweth.sub(_wethSoldInAttoweth).sub(_providerFeeInAttoeth).sub(_ethValueOfBurnedMkrInAttoeth); require(_payoutOwnerInAttoeth >= _minimumValueInAttoeth); maker.free(_cdpId, _lockedPethInAttopeth); maker.exit(_lockedPethInAttopeth); maker.give(_cdpId, msg.sender); weth.withdraw(_payoutOwnerInAttoeth); require(_recipient.call.value(_payoutOwnerInAttoeth)()); emit CloseCup(msg.sender, uint256(_cdpId)); ",0,1
"38888.sol
",function withdraw() onlyOwner { if (!owner.call.value(this.balance)()) throw; ,0,1
"Reentrance_01.sol
",function withdrawBalance(){ if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; } userBalance[msg.sender] = 0; ,1,0
"31912.sol
","function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  { bytes32 _id = keccak256(""serveTx"",_to,_value,_txData); uint256 _txIndex = self.transactionInfo[_id].length; uint256 _required = self.requiredMajor; if(msg.sender != address(this)){ bool allGood; uint256 _amount; if(!_confirm) { allGood = revokeConfirm(self, _id); return (allGood,_id); } else { if(_to != 0) (allGood,_amount) = getAmount(_txData); if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){ require(self.ownerIndex[msg.sender] > 0); _required = getRequired(self, _to, _value, allGood,_amount); self.transactionInfo[_id].length++; self.transactionInfo[_id][_txIndex].confirmRequired = _required; self.transactionInfo[_id][_txIndex].day = now / 1 days; self.transactions[now / 1 days].push(_id); } else { _txIndex--; allGood = checkNotConfirmed(self, _id, _txIndex); if(!allGood) return (false,_id); self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender)); self.transactionInfo[_id][_txIndex].confirmCount++; } else { _txIndex--; if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) { self.currentSpend[0][1] += _value; self.currentSpend[_to][1] += _amount; self.transactionInfo[_id][_txIndex].success = true; if(_to == 0){ createContract(_txData, _value); } else { require(_to.call.value(_value)(_txData)); delete self.transactionInfo[_id][_txIndex].data; LogTransactionComplete(_id, _to, _value, _data); } else { if(self.transactionInfo[_id][_txIndex].data.length == 0) self.transactionInfo[_id][_txIndex].data = _data; uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount); LogTransactionConfirmed(_id, msg.sender, confirmsNeeded); return (true,_id); ",0,1
"35806.sol
","function withdraw(uint amount) { require(tokens[0][msg.sender] >= amount); tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount); require(msg.sender.call.value(amount)()); Withdraw(0, msg.sender, amount, tokens[0][msg.sender]); ",0,1
"21755.sol
","function Collect(uint _am) public payable  { var acc = Acc[msg.sender]; if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) { if(msg.sender.call.value(_am)())  { acc.balance-=_am; LogFile.AddMessage(msg.sender,_am,""Collect""); function()     public     payable   { Put(0); contract Log struct Message address Sender; string  Data; uint Val; uint  Time; Message[] public History; Message LastMsg; ",1,0
"10711.sol
","function withdrawTo(address _to) public auth { require(_to.call.value(address(this).balance)()); function unwrapAndSend(TokenInterface wethToken, address _to, uint wethAmt) internal { wethToken.withdraw(wethAmt); require(_to.call.value(wethAmt)()); function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) { wethToken.deposit.value(msg.value)(); if (wethToken.allowance(this, otc) < msg.value) { wethToken.approve(otc, uint(-1)); wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value); buyAmt = min(buyAmt, buyToken.balanceOf(this)); (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); require(buyToken.transfer(owner, feeAmt)); require(buyToken.transfer(msg.sender, buyAmtRemainder)); unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); function buyAllAmountPayEth(OtcInterface otc,TokenInterface buyToken,uint buyAmt,TokenInterface wethToken) public payable returns (uint wethAmt) { wethToken.deposit.value(msg.value)(); if (wethToken.allowance(this, otc) < msg.value) { wethToken.approve(otc, uint(-1)); wethAmt = otc.buyAllAmount(buyToken, buyAmt, wethToken, msg.value); buyAmt = min(buyAmt, buyToken.balanceOf(this)); (uint feeAmt, uint buyAmtRemainder) = fees.takeFee(buyAmt, buyToken); require(buyToken.transfer(owner, feeAmt)); require(buyToken.transfer(msg.sender, buyAmtRemainder)); unwrapAndSend(wethToken, msg.sender, sub(msg.value, wethAmt)); ",0,1
"33501.sol
","function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); Execution(transactionId); function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); ",0,1
"DAO.sol
","function payOut(address _recipient, uint _amount) returns (bool) { if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner)) throw; if (_recipient.call.value(_amount)()) { PayOut(_recipient, _amount); return true; } else { return false; contract TokenCreationInterface { uint public closingTime; uint public minTokensToCreate; bool public isFueled; address public privateCreation; ManagedAccount public extraBalance; mapping (address => uint256) weiGiven; function createTokenProxy(address _tokenHolder) returns (bool success) { if (now < closingTime && msg.value > 0 && (privateCreation == 0 || privateCreation == msg.sender)) { uint token = (msg.value * 20) / divisor(); extraBalance.call.value(msg.value - token)(); balances[_tokenHolder] += token; totalSupply += token; weiGiven[_tokenHolder] += msg.value; CreatedToken(_tokenHolder, token); if (totalSupply >= minTokensToCreate && !isFueled) { isFueled = true; FuelingToDate(totalSupply); return true; throw; function refund() noEther { if (now > closingTime && !isFueled) { if (extraBalance.balance >= extraBalance.accumulatedInput()) extraBalance.payOut(address(this), extraBalance.accumulatedInput()); if (msg.sender.call.value(weiGiven[msg.sender])()) { Refund(msg.sender, weiGiven[msg.sender]); totalSupply -= balances[msg.sender]; balances[msg.sender] = 0; weiGiven[msg.sender] = 0; function executeProposal(uint _proposalID, bytes _transactionData) noEther returns (bool _success) { Proposal p = proposals[_proposalID]; uint waitPeriod = p.newCurator ? splitExecutionPeriod : executeProposalPeriod; if (p.open && now > p.votingDeadline + waitPeriod) { closeProposal(_proposalID); return; if (now < p.votingDeadline || !p.open || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) { throw; if (!isRecipientAllowed(p.recipient)) { closeProposal(_proposalID); p.creator.send(p.proposalDeposit); return; bool proposalCheck = true; if (p.amount > actualBalance()) proposalCheck = false; uint quorum = p.yea + p.nay; if (_transactionData.length >= 4 && _transactionData[0] == 0x68 && _transactionData[1] == 0x37 && _transactionData[2] == 0xff && _transactionData[3] == 0x1e && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) { proposalCheck = false; if (quorum >= minQuorum(p.amount)) { if (!p.creator.send(p.proposalDeposit)) throw; lastTimeMinQuorumMet = now; if (quorum > totalSupply / 5) minQuorumDivisor = 5; if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) { if (!p.recipient.call.value(p.amount)(_transactionData)) throw; p.proposalPassed = true; _success = true; if (p.recipient != address(this) && p.recipient != address(rewardAccount) && p.recipient != address(DAOrewardAccount) && p.recipient != address(extraBalance) && p.recipient != address(curator)) { rewardToken[address(this)] += p.amount; totalRewardToken += p.amount; closeProposal(_proposalID); ProposalTallied(_proposalID, _success, quorum); function newContract(address _newContract){ if (msg.sender != address(this) || !allowedRecipients[_newContract]) return; if (!_newContract.call.value(address(this).balance)()) { throw; rewardToken[_newContract] += rewardToken[address(this)]; rewardToken[address(this)] = 0; DAOpaidOut[_newContract] += DAOpaidOut[address(this)]; DAOpaidOut[address(this)] = 0; ",1,0
"30178.sol
","function buy() payable notPaused() public returns(bool) { require(now >= salesStart); require(now < salesDeadline); uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE; require(tokensToBuy > 0); uint timeBonus = _calculateTimeBonus(tokensToBuy, now); uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value); uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus; require(token.transfer(msg.sender, totalTokensToTransfer)); LogBought(msg.sender, msg.value, totalTokensToTransfer, 0); require(wallet.call.value(msg.value)()); return true; ",0,1
"4679.sol
","function giveToken(address _buyer) internal { require( pendingTokenUser[_buyer] > 0, ""pendingTokenUser[_buyer] > 0"" ); tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]); tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]); soldTokens = soldTokens.add(pendingTokenUser[_buyer]); pendingTokenUser[_buyer] = 0; require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(""forwardEther()"") ) ) ); etherUser[_buyer] = 0; function forwardEther() onlyRC payable public returns(bool) { require(milestoneSystem.call.value(msg.value)(), ""wallet.call.value(msg.value)()""); return true; ",0,1
"17215.sol
","function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) { require(compatible223ex); require(isUnlockedBoth(_to)); require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if (isContract(_to)) { assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"14284.sol
","function payCharity() payable public { uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved); require(ethToPay > 1); totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay); if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) { totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay); ",0,1
"21111.sol
","function submitPool(uint amountInWei) public onlyOwner noReentrancy { require(contractStage < 3); require(receiverAddress != 0x00); require(block.number >= addressChangeBlock.add(6000)); require(contributionMin <= amountInWei && amountInWei <= this.balance); finalBalance = this.balance; require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))()); if (this.balance > 0) ethRefundAmount.push(this.balance); contractStage = 3; PoolSubmitted(receiverAddress, amountInWei); ",0,1
"26188.sol
",function GetPrizeFund() public payable { require(now>EndTime); require(Bids[msg.sender]>=MaxOffer); uint prizeAmount = Bids[msg.sender]+PrizeFund; PrizeFund = 0; Bids[msg.sender]=0; msg.sender.call.value(prizeAmount); function RevokeBid() public payable { require(now>EndTime); uint toTransfer = Bids[msg.sender]; Bids[msg.sender]=0; msg.sender.call.value(toTransfer); ,0,1
"14994.sol
","function collectOwedDividends() public returns (uint _amount) { _updateCreditedPoints(msg.sender); _amount = creditedPoints[msg.sender] / POINTS_PER_WEI; creditedPoints[msg.sender] = 0; dividendsCollected += _amount; emit CollectedDividends(now, msg.sender, _amount); require(msg.sender.call.value(_amount)()); ",0,1
"9600.sol
","function doSafeSendWData(address toAddr, bytes data, uint amount) internal { require(txMutex3847834 == false, ""ss-guard""); txMutex3847834 = true; require(toAddr.call.value(amount)(data), ""ss-failed""); txMutex3847834 = false; contract payoutAllC is safeSend { address private _payTo; event PayoutAll(address payTo, uint value); constructor(address initPayTo) public { assert(initPayTo != address(0)); _payTo = initPayTo; function doSafeSend(address toAddr, uint amount) internal { doSafeSendWData(toAddr, """", amount); ",0,1
"Bank.sol
",function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; ,1,0
"Bank.sol
",function withdraw(){ require(msg.sender.call.value(balances[msg.sender])()); balances[msg.sender]=0; contract Attacker{ address public bankAddr; uint attackCount = 0; constructor(address _bank){ bankAddr = _bank; ,1,0
"3985.sol
","function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable { require(this == target); bytes memory prefix = ""\x19Ethereum Signed Message:\n32""; bytes32 hash = keccak256(prefix, keccak256(target, data, nonce)); msgSender = ECRecovery.recover(hash, sig); require(msgSender == sender); require(nonces[msgSender]++ == nonce); require(target.call.value(msg.value)(data)); msgSender = address(0); ",0,1
"SimpleDAO.sol
",function withdraw(uint amount) { if (credit[msg.sender]>= amount) { msg.sender.call.value(amount)(); credit[msg.sender]-=amount; function getJackpot() { owner.send(this.balance); function() { dao.withdraw(dao.queryCredit(this)); contract Mallory2 { SimpleDAO public dao; address owner; bool public performAttack = true; function attack()  { dao.donate.value(1)(this); dao.withdraw(1); function getJackpot(){ dao.withdraw(dao.balance); owner.send(this.balance); performAttack = true; function() { if (performAttack) { performAttack = false; dao.withdraw(1); function getJackpot(){ dao.withdraw(dao.balance); owner.send(this.balance); performAttack = true; function() { if (performAttack) { performAttack = false; dao.withdraw(1); ,1,0
"35878.sol
","function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) forwardTo = owner; function() public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); ",0,1
"919.sol
","function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(this.call.value(msg.value)(data)); contract EternalStorageProxyForStormMultisender is OwnedUpgradeabilityProxy, EternalStorage { ",0,1
"35637.sol
","function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { require(balanceOf(msg.sender) >= _value); balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); ",0,1
