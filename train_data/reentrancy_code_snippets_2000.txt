1 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
2 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
3 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
4 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
5 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
6 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
7 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
8 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
9 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
10 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
11 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
12 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
13 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
14 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
15 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
16 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
17 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
18 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
19 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
20 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
21 14284.sol
14284.sol
function payCharity() payable public {
uint256 ethToPay = SafeMath.sub(totalEthCharityCollected, totalEthCharityRecieved);
require(ethToPay > 1);
totalEthCharityRecieved = SafeMath.add(totalEthCharityRecieved, ethToPay);
if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
totalEthCharityRecieved = SafeMath.sub(totalEthCharityRecieved, ethToPay);
0
---------------------------------
22 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
23 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
24 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
25 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
26 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
27 40366.sol
40366.sol
function execute(address _to, uint _value, bytes _data) {
if (!isRightBranch) throw;
if (msg.sender != owner) throw;
if (!_to.call.value (_value)(_data)) throw;
contract BranchSender {
bool public isRightBranch;
0
---------------------------------
28 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
29 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
30 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
31 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
32 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
33 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
34 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
35 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
36 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
37 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
38 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
39 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
40 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
41 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
42 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
43 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
44 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
45 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
46 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
47 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
48 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
49 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
50 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
51 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
52 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
53 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
54 2189.sol
2189.sol
function transferAndCall( address _to,  uint256 _value,   bytes _data) public payable whenNotPaused returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
contract GOeurekaSale is Claimable, gotTokenSaleConfig, Pausable, Salvageable {
using SafeMath for uint256;
GOeureka public token;
WhiteListedBasic public whiteListed;
uint256 public presaleEnd;
uint256 public saleEnd;
uint256 public minContribution;
address public multiSig;
uint256 public weiRaised;
uint256 public tokensRaised;
mapping(address => uint256) public contributions;
uint256 public numberOfContributors = 0;
uint public basicRate;
event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
event SaleClosed();
event HardcapReached();
event NewCapActivated(uint256 newCap);
constructor(GOeureka token_, WhiteListedBasic _whiteListed) public {
basicRate = 3000;
calculateRates();
presaleEnd = 1536508800;
saleEnd = 1543593600;
multiSig = MULTISIG_ETH;
token = token_;
whiteListed = _whiteListed;
bool allocated = false;
1
---------------------------------
55 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
56 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
57 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
58 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
59 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
60 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
61 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
62 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
63 27263.sol
27263.sol
function loggedTransfer(uint amount, bytes32 logMsg, address target, address currentOwner) payable{
if(msg.sender != address(this))throw;
if(target.call.value(amount)()) {
CashMove(amount, logMsg, target, currentOwner);
function Divest(uint amount)  public  {
if ( investors[msg.sender] > 0 && amount > 0)  {
this.loggedTransfer(amount, "", msg.sender, owner);
investors[msg.sender] -= amount;
function withdraw() public {
if(msg.sender==owner) {
this.loggedTransfer(this.balance, "", msg.sender, owner);
1
---------------------------------
64 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
65 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
66 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
67 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
68 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
69 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
70 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
71 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
72 22247.sol
22247.sol
function Collect(uint _am) public payable {
if(Accounts[msg.sender]>=MinSum && _am<=Accounts[msg.sender] && block.number>putBlock) {
if(msg.sender.call.value(_am)()) {
Accounts[msg.sender]-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()
public
payable
Put(msg.sender);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
73 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
74 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
75 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
76 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
77 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
78 37676.sol
37676.sol
function send(address _to, uint _value, bytes _data) only_owner {
if (!_to.call.value(_value)(_data)) throw;
Sent(_to, _value, _data);
0
---------------------------------
79 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
80 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
81 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
82 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
83 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
84 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
85 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
86 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
87 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
88 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
89 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
90 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
91 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
92 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
93 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
94 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
95 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
96 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
97 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
98 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
99 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
100 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
101 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
102 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
103 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
104 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
105 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
106 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
107 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
108 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
109 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
110 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
111 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
112 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
113 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
114 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
115 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
116 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
117 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
118 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
119 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
120 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
121 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
122 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
123 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
124 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
125 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
126 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
127 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
128 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
129 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
130 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
131 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
132 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
133 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
134 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
135 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
136 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
137 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
138 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
139 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
140 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
141 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
142 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
143 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
144 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
145 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
146 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
147 33410.sol
33410.sol
function executeTransaction(uint transactionId)  internal notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction tx = transactions[transactionId];
tx.executed = true;
if (tx.destination.call.value(tx.value)(tx.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
tx.executed = false;
function confirmTransaction(uint transactionId)  public ownerExists(msg.sender) transactionExists(transactionId)  notConfirmed(transactionId, msg.sender){
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
148 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
149 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
150 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
151 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
152 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
153 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
154 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
155 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
156 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
157 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
158 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
159 4472.sol
4472.sol
function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
0
---------------------------------
160 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
161 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
162 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
163 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
164 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
165 37474.sol
37474.sol
function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
require(msg.sender==owner);
require(_to.call.value(_value)(_data));
return 0;
0
---------------------------------
166 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
167 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
168 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
169 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
170 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
171 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
172 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
173 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
174 33835.sol
33835.sol
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
var x= m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
0
---------------------------------
175 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
176 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
177 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
178 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
179 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
180 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
181 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
182 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
183 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
184 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
185 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
186 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
187 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
188 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
189 1044.sol
1044.sol
function donateToWhale(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Donate(amount, whale, msg.sender);
function loseWager(uint256 amount) internal {
whale.call.value(amount)(bytes4(keccak256("donate()")));
totalDonated += amount;
emit Lose(amount, msg.sender);
1
---------------------------------
190 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
191 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
192 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
193 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
194 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
195 17573.sol
17573.sol
function transferFrom(address _from, address _to, uint256 _amount, bytes _data, string _custom_fallback) public  returns (bool success)    {
if (isContract(controller)) {
if (!TokenController(controller).onTransfer(_from, _to, _amount))
throw;
require(super.transferFrom(_from, _to, _amount));
if (isContract(_to)) {
ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), _from, _amount, _data);
ERC223Transfer(_from, _to, _amount, _data);
return true;
function transfer( address _to,  uint _amount, bytes _data,  string _custom_fallback)  public   returns (bool success)  {
return transferFrom(msg.sender, _to, _amount, _data, _custom_fallback);
0
---------------------------------
196 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
197 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
198 17215.sol
17215.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public isRunning returns (bool ok) {
require(compatible223ex);
require(isUnlockedBoth(_to));
require(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
if (isContract(_to)) {
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
0
---------------------------------
199 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
200 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
201 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
202 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
203 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
204 16057.sol
16057.sol
function callFirstTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
firstTarget.call.value(msg.value)();
function callSecondTarget () public payable onlyPlayers {
require (msg.value >= 0.005 ether);
secondTarget.call.value(msg.value)();
function winPrize() public payable onlyOwner {
owner.call.value(1 wei)();
0
---------------------------------
205 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
206 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
207 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
208 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
209 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
210 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
211 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
212 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
213 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
214 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
215 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
216 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
217 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
218 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
219 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
220 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
221 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
222 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
223 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
224 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
225 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
226 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
227 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
228 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
229 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
230 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
231 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
232 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
233 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
234 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
235 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
236 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
237 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
238 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
239 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
240 19402.sol
19402.sol
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock) throw;
uint tokens = safeMul(value, price());
if(safeAdd(crowdSaleSoldAmount, tokens)>crowdSaleCap) throw;
balances[recipient] = safeAdd(balances[recipient], tokens);
crowdSaleSoldAmount = safeAdd(crowdSaleSoldAmount, tokens);
totalSupply = safeAdd(totalSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
function price() constant returns(uint) {
if (block.number<startBlock || block.number > endBlock) return 0;
else  return crowdSalePrice;
function() public payable {
if(msg.value == 0) {
sendCandy(msg.sender);
}  else {
buyToken(msg.sender, msg.value);
0
---------------------------------
241 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
242 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
243 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
244 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
245 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
246 3054.sol
3054.sol
function player_withdrawPendingTransactions() public returns (bool){
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
1
---------------------------------
247 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
248 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
249 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
250 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
251 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
252 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
253 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
254 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
255 29517.sol
29517.sol
function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
require(msg.sender == admin);
require(to.call.value(value)(data));
0
---------------------------------
256 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
257 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
258 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
259 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
260 30046.sol
30046.sol
function executeTransaction() public onlyActiveUsersAllowed()  transactionMustBePending() {
Transaction storage transaction = transactions[transactions.length - 1];
require(now > transaction.time_initiated + users[transaction.initiated_by].waiting_time);
transaction.is_executed = true;
transaction.time_finalized = now;
transaction.finalized_by = msg.sender;
transaction.execution_successful = transaction.destination.call.value(
transaction.value)(transaction.data);
1
---------------------------------
261 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
262 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
263 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
264 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
265 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
266 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
267 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
268 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
269 27248.sol
27248.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public {
require(sigR.length == threshold);
require(sigR.length == sigS.length && sigR.length == sigV.length);
bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce);
address lastAdd = address(0);
for (uint i = 0; i < threshold; i++) {
address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
require(recovered > lastAdd && isOwner[recovered]);
lastAdd = recovered;
nonce = nonce + 1;
require(destination.call.value(value)(data));
0
---------------------------------
270 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
271 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
272 EtherStore.sol
EtherStore.sol
function withdrawFunds (uint256 _weiToWithdraw) public {
require(balances[msg.sender] >= _weiToWithdraw);
require(_weiToWithdraw <= withdrawalLimit);
require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
require(msg.sender.call.value(_weiToWithdraw)());
balances[msg.sender] -= _weiToWithdraw;
lastWithdrawTime[msg.sender] = now;
1
---------------------------------
273 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
274 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
275 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
276 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
277 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
278 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
279 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
280 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
281 40589.sol
40589.sol
function sendRobust(address to, uint value) internal {
if (!to.send(value)) {
if (!to.call.value(value)()) throw;
function _fillOrder(address _from, uint numTokens) internal returns (bool) {
if (numTokens == 0) throw;
if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;
if (!token.transferFrom(_from, owner, numTokens)) return false;
sendRobust(_from, numTokens * weiPerToken / decimalPlaces);
OrderFilled(_from, numTokens);
return true;
0
---------------------------------
282 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
283 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
284 11705.sol
11705.sol
function commonWithdraw(address token, uint value) internal {
require (tokens[token][msg.sender] >= value);
tokens[token][msg.sender] -= value;
totalDeposited[token] -= value;
require((token != 0)?
ERC20(token).transfer(msg.sender, value):
msg.sender.call.value(value)()
);
emit Withdraw(
token,
msg.sender,
value,
tokens[token][msg.sender]);
function withdraw(uint amount) public {
commonWithdraw(0, amount);
function withdrawToken(address token, uint amount) public {
commonWithdraw(token, amount);
0
---------------------------------
285 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
286 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
287 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
288 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
289 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
290 37891.sol
37891.sol
function claim() {
uint balance = balances[msg.sender];
require(balance > 0);
balances[msg.sender] = 0;
bool claimed = msg.sender.call.value(balance)();
require(claimed);
0
---------------------------------
291 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
292 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
293 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
294 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
295 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
296 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
297 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
298 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
299 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
300 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
301 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
302 23166.sol
23166.sol
function buy(address recipient) payable public duringCrowdSale  {
require(!halted);
require(msg.value >= 0.01 ether);
uint256 tokens = msg.value.mul(35e4);
require(tokens > 0);
require(saleTokenSupply.add(tokens)<=coinAllocation );
balances[recipient] = balances[recipient].add(tokens);
totalSupply_ = totalSupply_.add(tokens);
saleTokenSupply = saleTokenSupply.add(tokens);
salesVolume = salesVolume.add(msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(msg.sender, recipient, msg.value, tokens);
function TorusCoin(uint256 startDatetimeInSeconds, address founderWallet) public {
admin = msg.sender;
founder = founderWallet;
startDatetime = startDatetimeInSeconds;
endDatetime = startDatetime + 16 * 1 days;
function() public payable {
buy(msg.sender);
0
---------------------------------
303 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
304 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
305 40416.sol
40416.sol
function withdraw(uint amount) {
if (msg.value>0) throw;
if (tokens[0][msg.sender] < amount) throw;
tokens[0][msg.sender] -= amount;
if (!msg.sender.call.value(amount)()) throw;
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
306 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
307 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
308 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
309 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
310 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
311 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
312 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
313 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
314 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
315 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
316 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
317 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
318 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
319 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
320 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
321 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
322 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
323 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
324 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
325 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
326 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
327 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
328 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
329 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
330 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
331 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
332 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
333 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
334 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
335 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
336 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
337 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
338 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
339 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
340 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
341 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
342 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
343 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
344 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
345 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
346 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
347 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
348 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
349 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
350 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
351 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
352 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
353 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
354 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
355 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
356 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
357 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
358 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
359 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
360 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
361 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
362 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
363 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
364 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
365 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
366 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
367 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
368 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
369 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
370 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
371 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
372 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
373 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
374 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
375 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
376 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
377 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
378 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
379 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
380 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
381 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
382 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
383 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
384 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
385 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
386 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
387 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
388 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
389 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
390 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
391 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
392 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
393 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
394 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
395 37329.sol
37329.sol
function buyICO() onlyExecutorOrOwner {
if (getBlockNumber() < icoStartBlock) return;
if (this.balance == 0) return;
uint256 purchaseAmount = Math.min256(this.balance, purchaseCap);
assert(crowdSale.call.value(purchaseAmount)());
ICOPurchased(purchaseAmount);
0
---------------------------------
396 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
397 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
398 13076.sol
13076.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(    address _from,    address _to,    uint256 _value,    bytes _data  )    public payable returns (bool)  {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract TimedCrowdsale is Crowdsale {
using SafeMath for uint256;
uint256 public openingTime;
uint256 public closingTime;
modifier onlyWhileOpen {
require(block.timestamp >= openingTime && block.timestamp <= closingTime);
_;
1
---------------------------------
399 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
400 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
401 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
402 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
403 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
404 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
405 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
406 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
407 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
408 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
409 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
410 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
411 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
412 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
413 39890.sol
39890.sol
function authorizePayment(uint _idMilestone) internal {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if (milestone.status == MilestoneStatus.AuthorizedForPayment) throw;
milestone.status = MilestoneStatus.AuthorizedForPayment;
if(!milestone.paymentSource.call.value(0)(milestone.payData)) throw;
ProposalStatusChanged(_idMilestone, milestone.status);
function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.reviewer) ||(milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
function requestMilestonePayment(uint _idMilestone) campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((msg.sender != milestone.milestoneLeadLink)&&(msg.sender != recipient))  throw;
if ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw;
authorizePayment(_idMilestone);
function arbitrateApproveMilestone(uint _idMilestone) onlyArbitrator campaignNotCanceled notChanging {
if (_idMilestone >= milestones.length) throw;
Milestone milestone = milestones[_idMilestone];
if ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw;
authorizePayment(_idMilestone);
0
---------------------------------
414 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
415 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
416 35661.sol
35661.sol
function refund() stopInEmergency {
if(getState() != State.Refunding) throw;
address investor = msg.sender;
if(balances[investor] == 0) throw;
uint amount = balances[investor];
delete balances[investor];
if(!(investor.call.value(amount)())) throw;
Refunded(investor, amount);
0
---------------------------------
417 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
418 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
419 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
420 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
421 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
422 35649.sol
35649.sol
function playerWithdrawPendingTransactions() public  payoutsAreActive   returns (bool)  {
uint withdrawAmount = playerPendingWithdrawals[msg.sender];
playerPendingWithdrawals[msg.sender] = 0;
if (msg.sender.call.value(withdrawAmount)()) {
return true;
} else {
playerPendingWithdrawals[msg.sender] = withdrawAmount;
return false;
0
---------------------------------
423 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
424 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
425 39932.sol
39932.sol
function process(bytes32 _destination) payable returns (bool) {
if (msg.value < 100) throw;
var tax = msg.value * taxPerc / 100;
var refill = bytes4(sha3("refill(bytes32)"));
if ( !ledger.call.value(tax)(refill, taxman)|| !ledger.call.value(msg.value - tax)(refill, _destination)) throw;
return true;
contract Invoice is Mortal {
address   public signer;
uint      public closeBlock;
Comission public comission;
string    public description;
bytes32   public beneficiary;
uint      public value;
0
---------------------------------
426 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
427 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
428 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
429 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
430 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
431 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
432 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
433 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
434 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
435 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
436 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
437 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
438 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
439 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
440 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
441 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
442 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
443 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
444 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
445 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
446 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
447 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
448 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
449 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
450 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
451 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
452 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
453 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
454 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
455 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
456 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
457 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
458 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
459 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
460 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
461 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
462 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
463 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
464 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
465 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
466 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
467 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
468 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
469 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
470 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
471 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
472 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
473 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
474 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
475 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
476 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
477 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
478 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
479 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
480 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
481 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
482 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
483 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
484 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
485 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
486 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
487 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
488 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
489 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
490 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
491 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
492 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
493 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
494 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
495 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
496 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
497 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
498 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
499 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
500 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
501 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
502 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
503 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
504 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
505 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
506 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
507 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
508 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
509 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
510 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
511 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
512 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
513 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
514 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
515 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
516 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
517 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
518 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
519 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
520 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
521 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
522 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
523 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
524 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
525 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
526 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
527 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
528 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
529 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
530 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
531 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
532 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
533 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
534 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
535 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
536 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
537 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
538 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
539 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
540 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
541 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
542 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
543 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
544 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
545 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
546 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
547 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
548 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
549 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
550 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
551 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
552 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
553 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
554 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
555 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
556 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
557 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
558 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
559 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
560 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
561 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
562 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
563 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
564 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
565 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
566 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
567 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
568 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
569 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
570 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
571 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
572 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
573 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
574 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
575 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
576 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
577 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
578 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
579 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
580 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
581 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
582 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
583 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
584 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
585 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
586 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
587 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
588 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
589 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
590 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
591 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
592 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
593 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
594 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
595 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
596 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
597 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
598 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
599 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
600 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
601 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
602 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
603 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
604 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
605 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
606 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
607 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
608 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
609 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
610 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
611 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
612 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
613 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
614 31759.sol
31759.sol
function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination,  uint value, bytes data)  external {
bytes32 txHash = keccak256(byte(0x19),  byte(0), this, nonce++, destination, value, data  );
verifySignatures( sigV,sigR,sigS,txHash);
require(destination.call.value(value)(data));
0
---------------------------------
615 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
616 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
617 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
618 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
619 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
620 22902.sol
22902.sol
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) {
if (isContract(_to)) {
require(allowedAddresses[_to]);
if (balanceOf(msg.sender) < _value) revert();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
TransferContract(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
621 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
622 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
623 30337.sol
30337.sol
function withdrawPayments()  external   returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) {
throw;
success = true;
0
---------------------------------
624 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
625 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
626 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
627 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
628 2013.sol
2013.sol
function executeTransaction(address destination, uint value, bytes data) public onlyOwner{
if (destination.call.value(value)(data))
emit Execution(destination,value,data);
else
emit ExecutionFailure(destination,value,data);
library SafeMath {
0
---------------------------------
629 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
630 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
631 16643.sol
16643.sol
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
function fundPuppets() public payable {
require(msg.sender == owner);
_share = SafeMath.div(msg.value, 4);
extra[0].call.value(_share).gas(800000)();
extra[1].call.value(_share).gas(800000)();
extra[2].call.value(_share).gas(800000)();
extra[3].call.value(_share).gas(800000)();
function() payable public{
contract Puppet {
mapping (uint256 => address) public target;
mapping (uint256 => address) public master;
constructor() payable public{
target[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;
master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;
function() public payable{
if(msg.sender != target[0]){
target[0].call.value(msg.value).gas(600000)();
0
---------------------------------
632 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
633 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
634 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
635 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
636 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
637 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
638 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
639 31565.sol
31565.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
640 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
641 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
642 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
643 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
644 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
645 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
646 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
647 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
648 35878.sol
35878.sol
function Forwarder(address _creator, bytes32 _regName, address _owner)
public
RegBase(_creator, _regName, _owner)
forwardTo = owner;
function() public payable {
Forwarded(msg.sender, forwardTo, msg.value);
require(forwardTo.call.value(msg.value)(msg.data));
function createNew(bytes32 _regName, address _owner)
public
payable
feePaid
returns (address kAddr_)
kAddr_ = address(new Forwarder(msg.sender, _regName, _owner));
Created(msg.sender, _regName, kAddr_);
0
---------------------------------
649 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
650 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
651 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
652 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
653 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
654 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
655 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
656 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
657 6881.sol
6881.sol
function buyOne(ERC20 token, address _exchange, uint256 _value, bytes _data) payable public {
balances[msg.sender] = balances[msg.sender].add(msg.value);
uint256 tokenBalance = token.balanceOf(this);
require(_exchange.call.value(_value)(_data));
balances[msg.sender] = balances[msg.sender].sub(_value);
tokenBalances[msg.sender][token] = tokenBalances[msg.sender][token].add(token.balanceOf(this).sub(tokenBalance));
1
---------------------------------
658 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
659 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
660 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
661 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
662 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
663 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
664 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
665 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
666 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
667 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
668 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
669 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
670 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
671 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
672 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
673 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
674 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
675 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
676 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
677 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
678 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
679 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
680 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
681 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
682 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
683 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
684 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
685 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
686 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
687 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
688 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
689 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
690 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
691 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
692 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
693 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
694 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
695 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
696 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
697 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
698 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
699 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
700 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
701 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
702 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
703 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
704 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
705 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
706 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
707 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
708 PrivateBank.sol
PrivateBank.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
709 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
710 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
711 1123.sol
1123.sol
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns)  {
uint256 _p1 = _eth / 100;
uint256 _com = _eth / 50;
_com = _com.add(_p1);
uint256 _p3d;
if (!address(admin).call.value(_com)()) {
_p3d = _com;
_com = 0;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_p3d = _aff;
_p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));
if (_p3d > 0) {
admin.transfer(_p3d);
_eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000){
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000) {
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTx(_pID, _team, _eth, _keys, _eventData_);
function coreQR(address _realSender,uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)       private   {
if (plyrRnds_[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round_[_rID].eth < 400000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 4000000000000000000) {
uint256 _availableLimit = (4000000000000000000).sub(plyrRnds_[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000) {
uint256 _keys = (round_[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000){
updateTimer(_keys, _rID);
if (round_[_rID].plyr != _pID)
round_[_rID].plyr = _pID;
if (round_[_rID].team != _team)
round_[_rID].team = _team;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000) {
airDropTracker_++;
if (airdrop() == true) {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);
plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);
round_[_rID].keys = _keys.add(round_[_rID].keys);
round_[_rID].eth = _eth.add(round_[_rID].eth);
rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);
_eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);
endTxQR(_realSender,_pID, _team, _eth, _keys, _eventData_);
0
---------------------------------
712 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
713 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
714 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
715 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
716 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
717 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
718 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
719 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
720 39662.sol
39662.sol
function sendToCharger(uint id){
if (msg.sender != Owner && msg.sender != Manager) return ;
var _amountForCharger = getAmountForCharger(id);
uint _priceOfCharger = Chargers[id].Address.getPrice() ;
if(_priceOfCharger> _amountForCharger){
uint difference  = _priceOfCharger - _amountForCharger;
calculateCountOfInvestmetnsInQueue(difference,id);
if(!Chargers[id].Address.call.value(_priceOfCharger)())   throw;
0
---------------------------------
721 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
722 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
723 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
724 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
725 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
726 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
727 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
728 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
729 28974.sol
28974.sol
function pay(address _addr, uint256 count) public payable {
assert(changeable==true);
assert(msg.value >= price*count);
if(!founder.call.value(price*count)() || !msg.sender.call.value(msg.value-price*count)()){
revert();
s.update(_addr,count);
Buy(msg.sender,count);
function () public payable {
pay(msg.sender,1);
1
---------------------------------
730 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
731 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
732 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
733 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
734 27188.sol
27188.sol
function loggedTransfer(uint amount, bytes32 message, address target, address currentOwner) protected {
if(!target.call.value(amount)()) throw;
Transfer(amount, message, target, currentOwner);
function divest(uint amount) public {
if ( investors[msg.sender].investment == 0 || amount == 0) throw;
investors[msg.sender].investment -= amount;
sumInvested -= amount;
this.loggedTransfer(amount, "", msg.sender, owner);
function payDividend() public {
uint dividend = calculateDividend();
if (dividend == 0) throw;
investors[msg.sender].lastDividend = sumDividend;
this.loggedTransfer(dividend, "Dividend payment", msg.sender, owner);
function doTransfer(address target, uint amount) public onlyOwner {
this.loggedTransfer(amount, "Owner transfer", target, owner);
1
---------------------------------
735 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
736 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
737 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
738 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
739 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
740 10297.sol
10297.sol
function execute0(address to, uint256 value, bytes data) private returns (address created)  {
if (to == 0) {
created = create0(value, data);
} else {
require(to.call.value(value)(data));
0
---------------------------------
741 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
742 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
743 14620.sol
14620.sol
function transferEth(address walletToTransfer, uint256 weiAmount) onlyOwner payable public {
require(walletToTransfer != address(0));
require(address(this).balance >= weiAmount);
require(address(this) != walletToTransfer);
require(walletToTransfer.call.value(weiAmount)());
0
---------------------------------
744 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
745 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
746 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
747 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
748 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
749 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
750 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
751 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
752 38651.sol
38651.sol
function cancelBuyOrder(address token, uint price) {
bytes32 h = sha256(token, price, msg.sender);
uint remain = buyOrders[h];
delete buyOrders[h];
if (!msg.sender.call.value(remain)()) throw;
CancelBuyOrder(h,token,price,msg.sender);
0
---------------------------------
753 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
754 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
755 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
756 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
757 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
758 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
759 38888.sol
38888.sol
function withdraw() onlyOwner {
if (!owner.call.value(this.balance)()) throw;
0
---------------------------------
760 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
761 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
762 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
763 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
764 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
765 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
766 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
767 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
768 39994.sol
39994.sol
function safeSend(address _recipient, uint _ether) internal preventReentry()  returns (bool success_) {
if(!_recipient.call.value(_ether)()) throw;
success_ = true;
pragma solidity ^0.4.0;
contract Math
string constant VERSION = "Math 0.0.1 \n";
uint constant NULL = 0;
bool constant LT = false;
bool constant GT = true;
uint constant iTRUE = 1;
uint constant iFALSE = 0;
uint constant iPOS = 1;
uint constant iZERO = 0;
uint constant iNEG = uint(-1);
function withdraw(uint _ether) external canEnter  hasEther(msg.sender, _ether) returns (bool success_) {
etherBalance[msg.sender] -= _ether;
safeSend(msg.sender, _ether);
success_ = true;
0
---------------------------------
769 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
770 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
771 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
772 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
773 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
774 14741.sol
14741.sol
function transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback) private returns(bool success) {
require(balanceOf(msg.sender) > _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
emit Transfer(msg.sender, _to, _value, _data);
return true;
function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns(bool success) {
require(!frozenAccount[msg.sender]);
require(!frozenAccount[_to]);
if (isContract(_to)) {
return transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
775 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
776 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
777 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
778 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
779 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
780 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
781 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
782 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
783 29601.sol
29601.sol
function transferInternal(address from, address to, uint256 value, bytes data,  bool useCustomFallback, string customFallback )  internal returns (bool success) {
bool status = super.transferInternal(from, to, value);
if (status) {
if (isContract(to)) {
ContractReceiver receiver = ContractReceiver(to);
if (useCustomFallback) {
require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);
} else {
receiver.tokenFallback(from, value, data);
Transfer(from, to, value, data);
return status;
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
require(locked == false);
bool status = transferInternal(msg.sender, to, value, data, true, customFallback);
return status;
function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
return transferInternal(from, to, value, data, false, "");
function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
require(locked == false);
bytes memory data;
return transferInternal(from, to, value, data, false, "");
function claimableTransfer(
uint256 _time,
address _from,
address _to,
uint256 _value,
bytes _data,
bool _useCustomFallback,
string _customFallback
)
internal returns (bool success)
uint256 senderCurrentBalance = balanceOf(_from);
uint256 receiverCurrentBalance = balanceOf(_to);
uint256 _totalSupply = totalSupply();
bool status = super.transferInternal(_from, _to, _value, _data, _useCustomFallback, _customFallback);
require(status);
claimInternal(_time, _from, senderCurrentBalance, _totalSupply);
claimInternal(_time, _to, receiverCurrentBalance, _totalSupply);
return true;
0
---------------------------------
784 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
785 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
786 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
787 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
788 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
789 38724.sol
38724.sol
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
contract ERC20nator is StandardToken, Ownable {
address public fundraiserAddress;
bytes public fundraiserCallData;
uint constant issueFeePercent = 2;
event requestedRedeem(address indexed requestor, uint amount);
event redeemed(address redeemer, uint amount);
function() payable {
uint issuedTokens = msg.value * (100 - issueFeePercent) / 100;
if(!owner.send(msg.value - issuedTokens)) throw;
if(!fundraiserAddress.call.value(issuedTokens)(fundraiserCallData))  throw;
totalSupply += issuedTokens;
balances[msg.sender] += issuedTokens;
1
---------------------------------
790 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
791 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
792 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
793 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
794 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
795 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
796 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
797 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
798 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
799 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
800 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
801 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
802 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
803 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
804 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
805 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
806 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
807 21277.sol
21277.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyManager returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
modifier onlyManager
require(msg.sender == manager);
_;
contract EthernameRaw is Managed {
event Transfer(
address indexed from,
address indexed to,
bytes32 indexed name
);
event Approval(
address indexed owner,
address indexed approved,
bytes32 indexed name
);
event SendEther(
address indexed from,
address indexed to,
bytes32 sender,
bytes32 recipient,
uint256 value
);
event Name(address indexed owner, bytes32 indexed name);
event Price(bytes32 indexed name, uint256 price);
event Buy(bytes32 indexed name, address buyer, uint256 price);
event Attribute(bytes32 indexed name, bytes32 key);
struct Record {
address owner;
uint256 price;
mapping (bytes32 => bytes) attrs;
string public constant name = "Ethername";
string public constant symbol = "ENM";
mapping (address => bytes32) public ownerToName;
mapping (bytes32 => Record) public nameToRecord;
mapping (bytes32 => address) public nameToApproved;
0
---------------------------------
808 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
809 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
810 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
811 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
812 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
813 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
814 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
815 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
816 18145.sol
18145.sol
function ___upgradeToAndCall(address newTarget, bytes data) payable public _onlyProxyOwner {
___upgradeTo(newTarget);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
817 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
818 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
819 12454.sol
12454.sol
function submitPool(uint256 weiAmount) public onlyAdmin noReentrancy {
require(contractStage < CONTRACT_SUBMIT_FUNDS, "Cannot resubmit pool.");
require(receiverAddress != 0x00, "receiver address cannot be empty");
uint256 contractBalance = address(this).balance;
if(weiAmount == 0){
weiAmount = contractBalance;
require(minContribution <= weiAmount && weiAmount <= contractBalance, "submitted amount too small or larger than the balance");
finalBalance = contractBalance;
require(receiverAddress.call.value(weiAmount).gas(gasleft().sub(5000))(),"Error submitting pool to receivingAddress");
contractBalance = address(this).balance;
if(contractBalance > 0) {
ethRefundAmount.push(contractBalance);
contractStage = CONTRACT_SUBMIT_FUNDS;
emit PoolSubmitted(receiverAddress, weiAmount);
0
---------------------------------
820 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
821 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
822 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
823 30178.sol
30178.sol
function buy() payable notPaused() public returns(bool) {
require(now >= salesStart);
require(now < salesDeadline);
uint tokensToBuy = msg.value * MULTIPLIER / TOKEN_PRICE;
require(tokensToBuy > 0);
uint timeBonus = _calculateTimeBonus(tokensToBuy, now);
uint volumeBonus = _calculateVolumeBonus(tokensToBuy, msg.sender, msg.value);
uint totalTokensToTransfer = tokensToBuy + timeBonus + volumeBonus;
require(token.transfer(msg.sender, totalTokensToTransfer));
LogBought(msg.sender, msg.value, totalTokensToTransfer, 0);
require(wallet.call.value(msg.value)());
return true;
0
---------------------------------
824 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
825 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
826 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
827 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
828 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
829 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
830 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
831 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
832 4598.sol
4598.sol
function futrMiner() public payable {
require(futr.call.value(msg.value)());
uint256 mined = ERC20(futr).balanceOf(address(this));
ERC20(futr).approve(mny, mined);
MNY(mny).mine(futr, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
function futxMiner() public payable {
require(futx.call.value(msg.value)());
uint256 mined = ERC20(futx).balanceOf(address(this));
ERC20(futx).approve(mny, mined);
MNY(mny).mine(futx, mined);
uint256 amount = ERC20(mny).balanceOf(address(this));
ERC20(mny).transfer(msg.sender, amount);
0
---------------------------------
833 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
834 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
835 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
836 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
837 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
838 Bank_attack.sol
Bank_attack.sol
function step1(uint256 amount)  payable {
if (this.balance >= amount) {
victim.call.value(amount)(bytes4(keccak256("Deposit()")));
function startAttack(uint256 amount)  {
step1(amount);
step2(amount / 2);
1
---------------------------------
839 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
840 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
841 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
842 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
843 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
844 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
845 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
846 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
847 22805.sol
22805.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
848 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
849 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
850 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
851 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
852 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
853 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
854 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
855 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
856 Reentrance_exploit.sol
Reentrance_exploit.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
857 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
858 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
859 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
860 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
861 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
862 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
863 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
864 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
865 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
866 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
867 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
868 14353.sol
14353.sol
function buy(){
require(sale != 0x0);
require(sale.call.value(this.balance)());
1
---------------------------------
869 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
870 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
871 2301.sol
2301.sol
function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {
_target.call.value(_value)(_data);
0
---------------------------------
872 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
873 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
874 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
875 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
876 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
877 33851.sol
33851.sol
function donate( bytes32 hash) payable {
print(hash);
if (block.number<startBlock || block.number>endBlock || (saleEtherRaised + msg.value)>etherCap || halted) throw;
uint256 tokens = (msg.value * price());
balances[msg.sender] = (balances[msg.sender] + tokens);
totalSupply = (totalSupply + tokens);
saleEtherRaised = (saleEtherRaised + msg.value);
if (!founder.call.value(msg.value)()) throw;
Donate(msg.value, tokens);
0
---------------------------------
878 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
879 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
880 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
881 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
882 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
883 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
884 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
885 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
886 36732.sol
36732.sol
function claim_bounty(){
if (this.balance < eth_minimum) return;
if (bought_tokens) return;
if (now < earliest_buy_time) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
uint256 claimed_bounty = buy_bounty;
buy_bounty = 0;
contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);
require(sale.call.value(contract_eth_value)());
msg.sender.transfer(claimed_bounty);
0
---------------------------------
887 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
888 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
889 27159.sol
27159.sol
function transfer(address to, uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(rx.call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
890 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
891 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
892 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
893 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
894 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
895 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
896 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
897 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
898 27398.sol
27398.sol
function Command(address adr,bytes data) payable public {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
899 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
900 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
901 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
902 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
903 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
904 15458.sol
15458.sol
function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool success) {
_transfer( msg.sender, to, value, data );
require(address(to).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data));
return true;
function transfer(address to, uint256 value) public  returns (bool success)  {
bytes memory empty;
_transfer(msg.sender, to, value, empty);
return true;
function transferFrom( address from, address to, uint256 value ) public  returns (bool success)  {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer(from, to, value, empty);
return true;
function transfer( address to, uint value, bytes data ) public  returns (bool success)  {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer( msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private  returns (bool success)  {
_transfer( msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
if (isContract(rx)) {
rx.tokenFallback( msg.sender, value, data );
return true;
return false;
1
---------------------------------
905 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
906 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
907 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
908 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
909 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
910 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
911 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
912 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
913 35617.sol
35617.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
914 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
915 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
916 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
917 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
918 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
919 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
920 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
921 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
922 19128.sol
19128.sol
function doWithdraw(address from, address to, uint256 amount) internal {
require(amount <= MAX_WITHDRAWAL);
require(balances[from] >= amount);
require(withdrawalCount[from] < 3);
balances[from] = balances[from].sub(amount);
to.call.value(amount)();
withdrawalCount[from] = withdrawalCount[from].add(1);
function withdraw(uint256 amount) public {
doWithdraw(msg.sender, msg.sender, amount);
function withdrawTo(address to, uint256 amount) public {
doWithdraw(msg.sender, to, amount);
function withdrawFor(address from, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, msg.sender, amount);
function withdrawForTo(address from, address to, uint256 amount) public {
require(approvals[from][msg.sender]);
doWithdraw(from, to, amount);
1
---------------------------------
923 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
924 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
925 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
926 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
927 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
928 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
929 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
930 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
931 Victim.sol
Victim.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
1
---------------------------------
932 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
933 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
934 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
935 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
936 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
937 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
938 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
939 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
940 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
941 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
942 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
943 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
944 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
945 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
946 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
947 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
948 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
949 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
950 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
951 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
952 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
953 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
954 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
955 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
956 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
957 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
958 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
959 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
960 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
961 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
962 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
963 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
964 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
965 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
966 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
967 25808.sol
25808.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
968 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
969 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
970 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
971 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
972 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
973 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
974 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
975 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
976 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
977 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
978 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
979 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
980 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
981 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
982 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
983 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
984 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
985 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
986 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
987 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
988 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
989 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
990 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
991 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
992 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
993 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
994 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
995 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
996 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
997 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
998 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
999 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1000 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1001 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1002 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1003 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1004 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1005 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1006 21111.sol
21111.sol
function submitPool(uint amountInWei) public onlyOwner noReentrancy {
require(contractStage < 3);
require(receiverAddress != 0x00);
require(block.number >= addressChangeBlock.add(6000));
require(contributionMin <= amountInWei && amountInWei <= this.balance);
finalBalance = this.balance;
require(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());
if (this.balance > 0) ethRefundAmount.push(this.balance);
contractStage = 3;
PoolSubmitted(receiverAddress, amountInWei);
0
---------------------------------
1007 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1008 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1009 33501.sol
33501.sol
function executeTransaction(bytes32 transactionId)   public   notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1010 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1011 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1012 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1013 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1014 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1015 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1016 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1017 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1018 Reentrance_01.sol
Reentrance_01.sol
function withdrawBalance(){
if(!(msg.sender.call.value(userBalance[msg.sender])())){
throw;
userBalance[msg.sender] = 0;
1
---------------------------------
1019 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1020 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1021 1751.sol
1751.sol
function proxy(address target, bytes data) public payable {
target.call.value(msg.value)(data);
contract VaultProxy is Proxy {
address public Owner;
mapping (address => uint256) public Deposits;
1
---------------------------------
1022 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1023 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1024 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1025 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1026 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1027 14579.sol
14579.sol
function pay() public onlyOwner whenNotCanceled {
require(weiCollected > 0);
uint256 fee;
uint256 netAmount;
(fee, netAmount) = _getFeeAndNetAmount(weiCollected);
require(address(sale).call.value(netAmount)(this));
tokensReceived = getToken().balanceOf(this);
if (fee != 0) {
manager.transfer(fee);
paid = true;
emit Paid(netAmount, fee);
0
---------------------------------
1028 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1029 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1030 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1031 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1032 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1033 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1034 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1035 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1036 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1037 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1038 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1039 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1040 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1041 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1042 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1043 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1044 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1045 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1046 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1047 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1048 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1049 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1050 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1051 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1052 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1053 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1054 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1055 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1056 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1057 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1058 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1059 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1060 37836.sol
37836.sol
function collect() onlyOwner {
require(addrcnt.call.value(this.balance)(0));
Collect(addrcnt,this.balance);
0
---------------------------------
1061 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1062 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1063 774.sol
774.sol
function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_) private returns(FDDdatasets.EventReturns) {
uint256 _com = _eth * 5 / 100;
uint256 _aff = _eth * 10 / 100;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit FDDEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now);
} else {
_com += _aff;
if (!address(Bank).call.value(_com)(bytes4(keccak256("deposit()"))))  {  }
return(_eventData_);
function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, FDDdatasets.EventReturns memory _eventData_)  private  {
if (plyrRnds[_pID][_rID].keys == 0)
_eventData_ = managePlayer(_pID, _eventData_);
if (round[_rID].eth < 100000000000000000000 && plyrRnds[_pID][_rID].eth.add(_eth) > 10000000000000000000)  {
uint256 _availableLimit = (10000000000000000000).sub(plyrRnds[_pID][_rID].eth);
uint256 _refund = _eth.sub(_availableLimit);
plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);
_eth = _availableLimit;
if (_eth > 1000000000)  {
uint256 _keys = (round[_rID].eth).keysRec(_eth);
if (_keys >= 1000000000000000000)   {
updateTimer(_keys, _rID);
if (round[_rID].plyr != _pID)
round[_rID].plyr = _pID;
_eventData_.compressedData = _eventData_.compressedData + 100;
if (_eth >= 100000000000000000)  {
airDropTracker_++;
if (airdrop() == true)  {
uint256 _prize;
if (_eth >= 10000000000000000000) {
_prize = ((airDropPot_).mul(75)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 300000000000000000000000000000000;
} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {
_prize = ((airDropPot_).mul(50)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 200000000000000000000000000000000;
} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {
_prize = ((airDropPot_).mul(25)) / 100;
plyr_[_pID].win = (plyr_[_pID].win).add(_prize);
airDropPot_ = (airDropPot_).sub(_prize);
_eventData_.compressedData += 100000000000000000000000000000000;
_eventData_.compressedData += 10000000000000000000000000000000;
_eventData_.compressedData += _prize * 1000000000000000000000000000000000;
airDropTracker_ = 0;
_eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);
plyrRnds[_pID][_rID].keys = _keys.add(plyrRnds[_pID][_rID].keys);
plyrRnds[_pID][_rID].eth = _eth.add(plyrRnds[_pID][_rID].eth);
round[_rID].keys = _keys.add(round[_rID].keys);
round[_rID].eth = _eth.add(round[_rID].eth);
_eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_);
_eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_);
endTx(_pID, _eth, _keys, _eventData_);
plyrRnds_[_pID] = plyrRnds[_pID][_rID];
round_ = round[_rID];
0
---------------------------------
1064 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1065 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1066 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1067 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1068 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1069 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1070 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1071 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1072 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1073 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1074 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1075 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1076 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1077 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1078 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1079 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1080 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1081 Reentrance_03.sol
Reentrance_03.sol
function withdrawBalance_fixed(){
uint amount = userBalance[msg.sender];
userBalance[msg.sender] = 0;
if(!(msg.sender.call.value(amount)())){ throw; }
0
---------------------------------
1082 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1083 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1084 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1085 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1086 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1087 7530.sol
7530.sol
function execute(address _to, uint _value, bytes _data) external onlyOwner {
SingleTransact(msg.sender, _value, _to, _data);
_to.call.value(_value)(_data);
0
---------------------------------
1088 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1089 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1090 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1091 36645.sol
36645.sol
function purchase_tokens() {
require(msg.sender == developer);
if (this.balance < eth_minimum) return;
if (kill_switch) return;
require(sale != 0x0);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
require(this.balance==0);
0
---------------------------------
1092 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1093 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1094 39749.sol
39749.sol
function calcRefund(address _addressToRefund) internal {
uint amount = balanceOf[_addressToRefund];
balanceOf[_addressToRefund] = 0;
if (amount > 0) {
if (_addressToRefund.call.value(amount)()) {
LogFundTransfer(_addressToRefund, amount, false);
} else {
balanceOf[_addressToRefund] = amount;
function safeWithdraw() public onlyAfterDeadline {
if (amountRaised >= fundingGoal){
fundingGoalReached = true;
LogGoalReached(bankRollBeneficiary, amountRaised);
crowdsaleClosed = true;
if (!fundingGoalReached) {
calcRefund(msg.sender);
if (msg.sender == owner && fundingGoalReached) {
bankrollBeneficiaryAmount = (this.balance*80)/100;
if (bankRollBeneficiary.send(bankrollBeneficiaryAmount)) {
LogFundTransfer(bankRollBeneficiary, bankrollBeneficiaryAmount, false);
etherollBeneficiaryAmount = this.balance;
if(!etherollBeneficiary.send(etherollBeneficiaryAmount)) throw;
LogFundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);
} else {
fundingGoalReached = false;
function emergencyWithdraw() public isEmergency {
calcRefund(msg.sender);
0
---------------------------------
1095 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1096 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1097 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1098 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1099 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1100 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1101 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1102 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1103 36334.sol
36334.sol
function buy_the_tokens() {
require(msg.sender == owner);
require(!bought_tokens);
require(sale != 0x0);
require(this.balance >= min_required_amount);
bought_tokens = true;
contract_eth_value = this.balance;
require(sale.call.value(contract_eth_value)());
0
---------------------------------
1104 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1105 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1106 28687.sol
28687.sol
function CashOut(uint _am)  {
if(_am<=balances[msg.sender]) {
if(msg.sender.call.value(_am)()) {
balances[msg.sender]-=_am;
TransferLog.AddMessage(msg.sender,_am,"CashOut");
function() public payable{}
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1107 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1108 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1109 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1110 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1111 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1112 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1113 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1114 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1115 1430.sol
1430.sol
function callContract(address to, bytes data) onlyOwner public payable returns (bool) {
require(to.call.value(msg.value)(data));
return true;
0
---------------------------------
1116 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1117 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1118 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1119 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1120 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1121 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1122 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1123 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1124 23088.sol
23088.sol
function atomicize (address[] addrs, uint[] values, uint[] calldataLengths, bytes calldatas) public{
require(addrs.length == values.length && addrs.length == calldataLengths.length);
uint j = 0;
for (uint i = 0; i < addrs.length; i++) {
bytes memory calldata = new bytes(calldataLengths[i]);
for (uint k = 0; k < calldataLengths[i]; k++) {
calldata[k] = calldatas[j];
j++;
require(addrs[i].call.value(values[i])(calldata));
1
---------------------------------
1125 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1126 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1127 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1128 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1129 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1130 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1131 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1132 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1133 Reentrance_02.sol
Reentrance_02.sol
function withdraw(uint _amount) public {
if(balances[msg.sender] >= _amount) {
if(msg.sender.call.value(_amount)()) {
_amount;
balances[msg.sender] -= _amount;
function() public payable {}
1
---------------------------------
1134 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1135 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1136 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1137 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1138 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1139 26523.sol
26523.sol
function claim_reward(uint uid, bytes32 passcode) public payable{
require(msg.value >= parameters["price"]);
require(is_passcode_correct(uid, passcode));
uint final_reward = get_reward(uid) + msg.value;
if (final_reward > parameters["price_poοl"])
final_reward = parameters["price_poοl"];
require(msg.sender.call.value(final_reward)());
parameters["price_poοl"] -= final_reward;
if (uid + 1 < users.length)
users[uid] = users[users.length - 1];
users.length -= 1;
1
---------------------------------
1140 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1141 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1142 SimpleDAO.sol
SimpleDAO.sol
function withdraw(uint amount) {
if (credit[msg.sender]>= amount) {
msg.sender.call.value(amount)();
credit[msg.sender]-=amount;
1
---------------------------------
1143 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1144 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1145 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1146 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1147 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1148 21241.sol
21241.sol
function finish() onlyOwner saleCompletedSuccessfully public {
uint256 freeEthers = address(this).balance * 40 / 100;
uint256 vestedEthers = address(this).balance - freeEthers;
address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers);
assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)());
AuctusToken token = AuctusToken(auctusTokenAddress);
token.setTokenSaleFinished();
if (remainingTokens > 0) {
token.burn(remainingTokens);
remainingTokens = 0;
0
---------------------------------
1149 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1150 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1151 39817.sol
39817.sol
function callDividend(address token_) owned {
assert(tokenManage[token_].hasDividend);
assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData));
function buyEther(uint256 amount) {
assert(valueToToken(etherContract,balances[msg.sender]) >= amount);
assert(destroyValue(msg.sender, tokenToValue(etherContract,amount)));
assert(msg.sender.call.value(amount)());
Buy(etherContract, msg.sender, amount, balances[msg.sender]);
function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock {
uint256 inValue;
uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value),
tokenToValue(tokenFrom,input));
inValue = valueWithFee(tempInValue);
uint256 outValue = valueToToken(tokenTo,inValue);
assert(verifiedTransferFrom(tokenFrom,msg.sender,input));
if (tokenTo == etherContract){
assert(msg.sender.call.value(outValue)());
} else assert(Token(tokenTo).transfer(msg.sender, outValue));
Trade(tokenFrom, tokenTo, msg.sender, inValue);
function takeEtherProfits(){
ShopKeeper(shopKeeperLocation).splitProfits();
ValueTrader shop = ValueTrader(shopLocation);
shop.buyEther(shop.balanceOf(this));
assert(profitContainerLocation.call.value(this.balance)());
0
---------------------------------
1152 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1153 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1154 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1155 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1156 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1157 9920.sol
9920.sol
function tryExec(address target, bytes calldata, uint value) internal returns (bool call_ret){
return target.call.value(value)(calldata);
function exec(address target, bytes calldata, uint value) internal {
if(!tryExec(target, calldata, value)) {
throw;
function tryExec( address t, bytes c ) internal returns (bool) {
return tryExec(t, c, 0);
function tryExec( address t, uint256 v ) internal returns (bool) {
bytes memory c; return tryExec(t, c, v);
contract DSMath {
0
---------------------------------
1158 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1159 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1160 32605.sol
32605.sol
function forward(address destination, uint value, bytes data) public onlyOwner {
require(destination.call.value(value)(data));
Forwarded(destination, value, data);
contract MetaIdentityManager {
uint adminTimeLock;
uint userTimeLock;
uint adminRate;
address relay;
event LogIdentityCreated(
address indexed identity,
address indexed creator,
address owner,
address indexed recoveryKey);
event LogOwnerAdded(
address indexed identity,
address indexed owner,
address instigator);
event LogOwnerRemoved(
address indexed identity,
address indexed owner,
address instigator);
event LogRecoveryChanged(
address indexed identity,
address indexed recoveryKey,
address instigator);
event LogMigrationInitiated(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationCanceled(
address indexed identity,
address indexed newIdManager,
address instigator);
event LogMigrationFinalized(
address indexed identity,
address indexed newIdManager,
address instigator);
mapping(address => mapping(address => uint)) owners;
mapping(address => address) recoveryKeys;
mapping(address => mapping(address => uint)) limiter;
mapping(address => uint) public migrationInitiated;
mapping(address => address) public migrationNewAddress;
modifier onlyAuthorized() {
require(msg.sender == relay || checkMessageData(msg.sender));
_;
modifier onlyOwner(address identity, address sender) {
require(isOwner(identity, sender));
_;
modifier onlyOlderOwner(address identity, address sender) {
require(isOlderOwner(identity, sender));
_;
modifier onlyRecovery(address identity, address sender) {
require(recoveryKeys[identity] == sender);
_;
modifier rateLimited(Proxy identity, address sender) {
require(limiter[identity][sender] < (now - adminRate));
limiter[identity][sender] = now;
_;
modifier validAddress(address addr) {
require(addr != address(0));
_;
function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) {
Proxy identity = new Proxy();
owners[identity][owner] = now - adminTimeLock;
recoveryKeys[identity] = recoveryKey;
LogIdentityCreated(identity, msg.sender, owner,  recoveryKey);
identity.forward(destination, 0, data);
function forwardTo(address sender, Proxy identity, address destination, uint value, bytes data) public onlyAuthorized onlyOwner(identity, sender){
identity.forward(destination, value, data);
0
---------------------------------
1161 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1162 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1163 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1164 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1165 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1166 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1167 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1168 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1169 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1170 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1171 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1172 22416.sol
22416.sol
function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
if(Holders[_addr]>0)  {
if(_addr.call.value(_wei)()){
Holders[_addr]-=_wei;
0
---------------------------------
1173 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1174 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1175 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1176 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1177 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1178 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1179 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1180 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1181 40090.sol
40090.sol
function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) {
return _to.call.value(_value)(_data);
function() returns(bool) {
return multiAccessCall(multiAccessRecipient, msg.value, msg.data);
function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) {
return this.multiAccessCallD(_to, _value, _data, msg.sender);
0
---------------------------------
1182 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1183 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1184 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1185 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1186 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1187 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1188 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1189 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1190 Bank.sol
Bank.sol
function withdraw(){
require(msg.sender.call.value(balances[msg.sender])());
balances[msg.sender]=0;
contract Attacker{
address public bankAddr;
uint attackCount = 0;
constructor(address _bank){
bankAddr = _bank;
1
---------------------------------
1191 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1192 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1193 dumbDAO.sol
dumbDAO.sol
function withdraw(address _recipient) returns (bool) {
if (balances[msg.sender] == 0){
InsufficientFunds(balances[msg.sender],balances[msg.sender]);
throw;
PaymentCalled(_recipient, balances[msg.sender]);
if (_recipient.call.value(balances[msg.sender])()) {
balances[msg.sender] = 0;
return true;
1
---------------------------------
1194 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1195 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1196 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1197 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1198 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1199 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1200 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1201 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1202 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1203 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1204 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1205 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1206 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1207 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1208 8342.sol
8342.sol
function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) {
return _to.call.value(_value).gas(_gas)(_code);
0
---------------------------------
1209 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1210 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1211 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1212 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1213 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1214 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1215 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1216 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1217 31912.sol
31912.sol
function serveTx(WalletData storage self,  address _to, uint256 _value,  bytes _txData,  bool _confirm,    bytes _data)  public returns (bool,bytes32)  {
bytes32 _id = keccak256("serveTx",_to,_value,_txData);
uint256 _txIndex = self.transactionInfo[_id].length;
uint256 _required = self.requiredMajor;
if(msg.sender != address(this)){
bool allGood;
uint256 _amount;
if(!_confirm) {
allGood = revokeConfirm(self, _id);
return (allGood,_id);
} else {
if(_to != 0)
(allGood,_amount) = getAmount(_txData);
if(_txIndex == 0 || self.transactionInfo[_id][_txIndex - 1].success){
require(self.ownerIndex[msg.sender] > 0);
_required = getRequired(self, _to, _value, allGood,_amount);
self.transactionInfo[_id].length++;
self.transactionInfo[_id][_txIndex].confirmRequired = _required;
self.transactionInfo[_id][_txIndex].day = now / 1 days;
self.transactions[now / 1 days].push(_id);
} else {
_txIndex--;
allGood = checkNotConfirmed(self, _id, _txIndex);
if(!allGood)
return (false,_id);
self.transactionInfo[_id][_txIndex].confirmedOwners.push(uint256(msg.sender));
self.transactionInfo[_id][_txIndex].confirmCount++;
} else {
_txIndex--;
if(self.transactionInfo[_id][_txIndex].confirmCount ==  self.transactionInfo[_id][_txIndex].confirmRequired) {
self.currentSpend[0][1] += _value;
self.currentSpend[_to][1] += _amount;
self.transactionInfo[_id][_txIndex].success = true;
if(_to == 0){
createContract(_txData, _value);
} else {
require(_to.call.value(_value)(_txData));
delete self.transactionInfo[_id][_txIndex].data;
LogTransactionComplete(_id, _to, _value, _data);
} else {
if(self.transactionInfo[_id][_txIndex].data.length == 0)
self.transactionInfo[_id][_txIndex].data = _data;
uint256 confirmsNeeded = calcConfirmsNeeded(self.transactionInfo[_id][_txIndex].confirmRequired, self.transactionInfo[_id][_txIndex].confirmCount);
LogTransactionConfirmed(_id, msg.sender, confirmsNeeded);
return (true,_id);
0
---------------------------------
1218 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1219 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1220 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1221 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1222 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1223 17043.sol
17043.sol
function withdraw() public {
msg.sender.call.value(balances[msg.sender])();
balances[msg.sender] = 0;
1
---------------------------------
1224 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1225 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1226 18170.sol
18170.sol
function mintETHRewards( address _contract, uint256 _amount ) public onlyManager() {
require(_amount <= wingsETHRewards);
require(_contract.call.value(_amount)());
wingsETHRewards -= _amount;
0
---------------------------------
1227 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1228 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1229 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1230 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1231 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1232 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1233 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1234 40469.sol
40469.sol
function _forward(address _to, bytes _data) internal returns(bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return false;
_to.call.value(msg.value)(_data);
return _applyRefund(startGas);
0
---------------------------------
1235 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1236 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1237 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1238 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1239 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1240 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1241 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1242 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1243 33450.sol
33450.sol
function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){
if (isConfirmed(TransHash)) {
Transactions[TransHash].executed = true;
require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
Execution(TransHash);
function confirmTransaction(bytes32 TransHash) public onlyOwner(){
addConfirmation(TransHash);
executeTransaction(TransHash);
0
---------------------------------
1244 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1245 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1246 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1247 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1248 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1249 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1250 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1251 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1252 14945.sol
14945.sol
function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
1
---------------------------------
1253 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1254 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1255 4591.sol
4591.sol
function finishDistribution() onlyOwner canDistr public returns (bool) {
crowdsaleClosed = true;
uint256 amount = tokenReward.sub(amountRaisedIsc);
balances[beneficiary] = balances[beneficiary].add(amount);
emit Transfer(address(0), beneficiary, amount);
require(msg.sender.call.value(amountRaised)());
return true;
0
---------------------------------
1256 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1257 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1258 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1259 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1260 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1261 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1262 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1263 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1264 40092.sol
40092.sol
function withdrawPayments() external  returns (bool success) {
uint256 payment = payments[msg.sender];
payments[msg.sender] = 0;
totalBalance -= payment;
if (!msg.sender.call.value(payment)()) { throw; }
success = true;
0
---------------------------------
1265 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1266 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1267 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1268 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1269 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1270 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1271 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1272 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1273 simple_dao.sol
simple_dao.sol
function withdraw(uint amount) public{
if (credit[msg.sender]>= amount) {
require(msg.sender.call.value(amount)());
credit[msg.sender]-=amount;
1
---------------------------------
1274 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1275 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1276 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1277 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1278 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1279 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1280 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1281 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1282 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1283 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1284 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1285 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1286 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1287 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1288 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1289 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1290 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1291 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1292 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1293 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1294 1403.sol
1403.sol
function transfer( address to,   uint value,  bytes data, string custom_fallback ) public returns (bool success)  {
_transfer( msg.sender, to, value, data );
if ( isContract(to) ) {
ContractReceiver rx = ContractReceiver( to );
require(address(rx).call.value(0)(bytes4(keccak256(custom_fallback)), msg.sender, value, data) );
return true;
function transfer(address to, uint256 value) public returns (bool success) {
bytes memory empty;
_transfer( msg.sender, to, value, empty );
return true;
function transferFrom( address from, address to, uint256 value ) public returns (bool success) {
require( value <= allowances_[from][msg.sender] );
allowances_[from][msg.sender] -= value;
bytes memory empty;
_transfer( from, to, value, empty );
return true;
function transfer( address to, uint value, bytes data ) public returns (bool success) {
if (isContract(to)) {
return transferToContract( to, value, data );
_transfer(msg.sender, to, value, data );
return true;
function transferToContract( address to, uint value, bytes data ) private returns (bool success) {
_transfer(msg.sender, to, value, data );
ContractReceiver rx = ContractReceiver(to);
rx.tokenFallback( msg.sender, value, data );
return true;
1
---------------------------------
1295 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1296 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1297 21900.sol
21900.sol
function crowdsale() public payable returns (bool) {
require(msg.value >= limit);
uint256 vv = msg.value;
uint256 coin = crowdsalePrice.mul(vv);
require(coin.add(totalSupply) <= supplyLimit);
require(crowdsaleSupply.add(coin) <= crowdsaleTotal);
balances[msg.sender] = coin.add(balances[msg.sender]);
totalSupply = totalSupply.add(coin);
crowdsaleSupply = crowdsaleSupply.add(coin);
balances[msg.sender] = coin;
require(owner.call.value(msg.value)());
return true;
contract GGPCToken is Crowdsale {
string public name = "Global game payment currency";
string public symbol = "GGPC";
string public version = '1.0.2';
0
---------------------------------
1298 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1299 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1300 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1301 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1302 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1303 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1304 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1305 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1306 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1307 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1308 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1309 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1310 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1311 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1312 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1313 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1314 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1315 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1316 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1317 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1318 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1319 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1320 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1321 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1322 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1323 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1324 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1325 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1326 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1327 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1328 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1329 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1330 17518.sol
17518.sol
function sendTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1331 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1332 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1333 32559.sol
32559.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1334 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1335 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1336 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1337 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1338 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1339 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1340 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1341 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1342 40118.sol
40118.sol
function withdrawEtherOrThrow(uint256 amount) private {
if (msg.sender != owner) throw;
bool result = owner.call.value(amount)();
if (!result) { throw;}
function refund() noEther onlyOwner {
if (tokenBalance == 0) throw;
tokenBalance = 0;
withdrawEtherOrThrow(tokenBalance * tokenPrice);
0
---------------------------------
1343 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1344 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1345 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1346 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1347 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1348 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1349 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1350 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1351 cross-function-reentrancy.sol
cross-function-reentrancy.sol
function WithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
require(recipient.call.value(amountToWithdraw)());
function GetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {
throw;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
claimedBonus[recipient] = true;
1
---------------------------------
1352 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1353 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1354 25196.sol
25196.sol
function getTokens(uint num, address tokenBuyerContract) public {
tokenBuyerContract.call.value(0 wei)();
1
---------------------------------
1355 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1356 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1357 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1358 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1359 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1360 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1361 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1362 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1363 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1364 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1365 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1366 27024.sol
27024.sol
function participate() payable onlyHuman {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if (luckyNumberOfAddress(msg.sender) == winnerLuckyNumber)  {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1367 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1368 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1369 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1370 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1371 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1372 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1373 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1374 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1375 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1376 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1377 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1378 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1379 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1380 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1381 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1382 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1383 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1384 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1385 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1386 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1387 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1388 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1389 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1390 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1391 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1392 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1393 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1394 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1395 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1396 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1397 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1398 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1399 simple_dao_fixed.sol
simple_dao_fixed.sol
function withdraw(uint amount) public {
if (credit[msg.sender]>= amount) {
credit[msg.sender]-=amount;
require(msg.sender.call.value(amount)());
0
---------------------------------
1400 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1401 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1402 35421.sol
35421.sol
function tryExec(address target, bytes calldata, uint256 value) mutex() internal  returns (bool call_ret){
return target.call.value(value)(calldata);
function exec( address target, bytes calldata, uint256 value) internal {
assert(tryExec(target, calldata, value));
contract canFreeze is owned {
bool public frozen=false;
modifier LockIfFrozen() {
if (!frozen){
_;
function ActionRetStatic(Trans _details, uint _TransID,uint128 _Price) 	internal {
uint128 _ETHReturned;
if(0==Risk.totalSupply()){_Price=lastPrice;}
_ETHReturned = wdiv(_details.amount , _Price);
if (Static.meltCoin(_details.holder,_details.amount)){
EventRedeemStatic(_details.holder,_details.amount ,_TransID, _Price);
if (wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Static.mintCoin(_details.holder,_details.amount);
EventCreateStatic(_details.holder,_details.amount ,_TransID, _Price);
if ( 0==this.balance) {
Bankrupt();
function ActionRetRisk(Trans _details, uint _TransID,uint128 _Price) internal {
uint128 _ETHReturned;
uint128 CurRiskPrice;
CurRiskPrice=RiskPrice(_Price);
if(CurRiskPrice>0){
_ETHReturned = wdiv( wmul(_details.amount , CurRiskPrice) , _Price);
if (Risk.meltCoin(_details.holder,_details.amount )){
EventRedeemRisk(_details.holder,_details.amount ,_TransID, _Price);
if ( wless(cast(this.balance),_ETHReturned)) {
_ETHReturned=cast(this.balance);
bytes memory calldata;
if (tryExec(_details.holder, calldata, _ETHReturned)) {
} else {
Risk.mintCoin(_details.holder,_details.amount);
EventCreateRisk(_details.holder,_details.amount ,_TransID, _Price);
}  else {
0
---------------------------------
1403 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1404 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1405 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1406 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1407 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1408 347.sol
347.sol
function _forwardFunds() internal {
bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();
emit TokensTransfer (msg.sender, wallet, msg.value, isTransferDone);
0
---------------------------------
1409 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1410 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1411 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1412 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1413 3985.sol
3985.sol
function performFeelessTransaction(address sender, address target, bytes data, uint256 nonce, bytes sig) public payable {
require(this == target);
bytes memory prefix = "\x19Ethereum Signed Message:\n32";
bytes32 hash = keccak256(prefix, keccak256(target, data, nonce));
msgSender = ECRecovery.recover(hash, sig);
require(msgSender == sender);
require(nonces[msgSender]++ == nonce);
require(target.call.value(msg.value)(data));
msgSender = address(0);
0
---------------------------------
1414 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1415 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1416 39019.sol
39019.sol
function CreateTokens() {
if (tokensCreated > 0) return;
uint amount = amountRaised * (100 - rewardPercentage) / 100;
if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;
tokensCreated = tokenContract.balanceOf(this);
tokenCreator = msg.sender;
0
---------------------------------
1417 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1418 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1419 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1420 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1421 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1422 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1423 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1424 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1425 35637.sol
35637.sol
function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {
if(isContract(_to)) {
require(balanceOf(msg.sender) >= _value);
balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);
balances[_to] = safeAdd(balanceOf(_to), _value);
ContractReceiver receiver = ContractReceiver(_to);
receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1426 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1427 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1428 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1429 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1430 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1431 28869.sol
28869.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId)  {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public  ownerExists(msg.sender)  transactionExists(transactionId) notConfirmed(transactionId, msg.sender)  {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1432 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1433 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1434 18438.sol
18438.sol
function invest() public {
uint256 amountToSend = address(this).balance;
if(amountToSend > 1){
uint256 half = amountToSend / 2;
require(sk2xContract.call.value(half)());
p3dContract.buy.value(half)(msg.sender);
function donate() payable public {
require(sk2xContract.call.value(msg.value).gas(1000000)());
0
---------------------------------
1435 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1436 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1437 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1438 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1439 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1440 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1441 14758.sol
14758.sol
function wcf(address target, uint256 a) payable {
require(msg.sender == owner);
uint startBalance = this.balance;
target.call.value(msg.value)(bytes4(keccak256("play(uint256)")), a);
if (this.balance <= startBalance) revert();
owner.transfer(this.balance);
0
---------------------------------
1442 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1443 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1444 14994.sol
14994.sol
function collectOwedDividends() public returns (uint _amount) {
_updateCreditedPoints(msg.sender);
_amount = creditedPoints[msg.sender] / POINTS_PER_WEI;
creditedPoints[msg.sender] = 0;
dividendsCollected += _amount;
emit CollectedDividends(now, msg.sender, _amount);
require(msg.sender.call.value(_amount)());
0
---------------------------------
1445 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1446 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1447 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1448 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1449 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1450 35806.sol
35806.sol
function withdraw(uint amount) {
require(tokens[0][msg.sender] >= amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
require(msg.sender.call.value(amount)());
Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
0
---------------------------------
1451 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1452 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1453 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1454 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1455 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1456 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1457 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1458 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1459 40241.sol
40241.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1460 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1461 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1462 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1463 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1464 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1465 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1466 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1467 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1468 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1469 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1470 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1471 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1472 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1473 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1474 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1475 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1476 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1477 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1478 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1479 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1480 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1481 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1482 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1483 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1484 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1485 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1486 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1487 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1488 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1489 21697.sol
21697.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1490 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1491 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1492 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1493 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1494 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1495 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1496 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1497 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1498 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1499 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1500 10107.sol
10107.sol
function transfer(address to, uint value, bytes data, string customFallback) public returns (bool) {
if(balanceOf(msg.sender) < value) revert();
balances[msg.sender] = balances[msg.sender].sub(value);
balances[to] = balances[to].add(value);
if (isContract(to)) {
assert(to.call.value(0)(bytes4(keccak256(customFallback)), msg.sender, value, data));
emit Transfer(msg.sender, to, value, data);
return true;
0
---------------------------------
1501 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1502 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1503 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1504 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1505 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1506 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1507 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1508 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1509 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1510 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1511 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1512 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1513 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1514 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1515 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1516 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1517 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1518 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1519 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1520 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1521 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1522 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1523 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1524 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1525 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1526 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1527 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1528 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1529 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1530 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1531 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1532 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1533 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1534 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1535 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1536 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1537 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1538 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1539 39191.sol
39191.sol
function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {
if (self.accountBalances[accountAddress] >= value) {
deductFunds(self, accountAddress, value);
if (!accountAddress.send(value)) {
if (!accountAddress.call.value(value)()) {  throw; }
return true;
return false;
uint constant DEFAULT_SEND_GAS = 100000;
0
---------------------------------
1540 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1541 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1542 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1543 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1544 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1545 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1546 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1547 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1548 5515.sol
5515.sol
function executeTransaction(uint transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
transactions[transactionId].executed = true;
if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {
emit Execution(transactionId);
} else {
emit ExecutionFailure(transactionId);
transactions[transactionId].executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
emit Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1549 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1550 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1551 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1552 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1553 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1554 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1555 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1556 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1557 17009.sol
17009.sol
function Pay(address _destination) public payable {
require(_destination != 0x0);
require(msg.value > 0);
require(!paused);
masterWallet.transfer(msg.value.div(9));
_destination.call.value(msg.value.div(9).mul(8))();
SettleFund(_destination, msg.value);
1
---------------------------------
1558 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1559 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1560 23421.sol
23421.sol
function _safeCall(address _to, uint _amount) internal {
require(_to != 0);
require(_to.call.value(_amount)());
function multiCall(address[] _address, uint[] _amount) payable public returns(bool) {
for (uint i = 0; i < _address.length; i++) {
_safeCall(_address[i], _amount[i]);
return true;
1
---------------------------------
1561 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1562 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1563 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1564 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1565 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1566 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1567 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1568 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1569 27486.sol
27486.sol
function Command(address adr,bytes data)  payable  public  {
require(msg.sender == Owner);
adr.call.value(msg.value)(data);
0
---------------------------------
1570 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1571 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1572 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1573 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1574 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1575 40353.sol
40353.sol
function withdraw(uint256 tokens) noEther onlyDaoChallenge {
if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;
tokenBalance -= tokens;
if(!owner.call.value(tokens * tokenPrice)()) throw;
function withdraw(uint256 tokens) noEther {
DaoAccount account = accountFor(msg.sender, false);
if (account == DaoAccount(0x00)) throw;
account.withdraw(tokens);
notifyWithdraw(msg.sender, tokens);
0
---------------------------------
1576 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1577 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1578 39684.sol
39684.sol
function () payable {
if (msg.data.length > 0) {
createSeries(msg.data, 0, "", "", 0x0);
} else if (latestSeriesForUser[msg.sender] != 0) {
if (latestSeriesForUser[msg.sender].call.value(msg.value)())
DepositMade(latestSeriesForUser[msg.sender], msg.value);
} else {
createSeries("", 0, "", "", 0x0);
contract SeriesFactory {
address public seriesFactory;
address public owner;
0
---------------------------------
1579 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1580 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1581 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1582 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1583 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1584 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1585 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1586 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1587 9611.sol
9611.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1588 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1589 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1590 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1591 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1592 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1593 23387.sol
23387.sol
function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender)  notExecuted(transactionId){
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (txn.destination.call.value(txn.value)(txn.data))
Execution(transactionId);
else {
ExecutionFailure(transactionId);
txn.executed = false;
function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1594 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1595 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1596 27334.sol
27334.sol
function participate() payable {
require(msg.value == 0.1 ether);
require(!participated[msg.sender]);
if ( luckyNumberOfAddress(msg.sender) == luckyNumber) {
participated[msg.sender] = true;
require(msg.sender.call.value(this.balance)());
0
---------------------------------
1597 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1598 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1599 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1600 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1601 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1602 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1603 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1604 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1605 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1606 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1607 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1608 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1609 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1610 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1611 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1612 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1613 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1614 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1615 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1616 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1617 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1618 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1619 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1620 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1621 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1622 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1623 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1624 39644.sol
39644.sol
function revoke(address transactor, address transactee) {
if (msg.sender != transactor && msg.sender != transactee) { throw; }
if(!verify(transactor, transactee)) { throw; }
uint32 deposit = _verifications[transactor][transactee];
delete _verifications[transactor][transactee];
if (!transactee.call.value(deposit).gas(23000)()) {  throw;  }
RevokeEvent(transactor, transactee, deposit);
0
---------------------------------
1625 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1626 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1627 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1628 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1629 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1630 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1631 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1632 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1633 36563.sol
36563.sol
function forward(address _destination, uint256 _value, bytes _data) onlyOwner {
require(_destination != address(0));
assert(_destination.call.value(_value)(_data));
if (_value > 0) {
Withdrawal(_destination, _value, _data);
function() payable {
Deposit(msg.sender, msg.value);
0
---------------------------------
1634 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1635 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1636 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1637 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1638 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1639 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1640 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1641 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1642 11719.sol
11719.sol
function Collect(uint _am) public payable {
if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {
if(msg.sender.call.value(_am)())  {
balances[msg.sender]-=_am;
Log.AddMessage(msg.sender,_am,"Collect");
function() public payable {
Deposit();
contract LogFile
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1643 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1644 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1645 24007.sol
24007.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1646 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1647 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1648 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1649 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1650 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1651 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1652 1879.sol
1879.sol
function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {
_upgradeTo(newImplementation);
require(address(this).call.value(msg.value)(data));
0
---------------------------------
1653 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1654 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1655 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1656 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1657 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1658 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1659 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1660 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1661 39269.sol
39269.sol
function sendPending() public preventReentry isHolder(msg.sender) returns (bool){
if (ptxTail == ptxHead) return false;
TX memory tx = pendingTxs[ptxTail];
if(now < tx.timeLock) return false;
delete pendingTxs[ptxTail++];
if(!tx.blocked) {
if(tx.to.call.value(tx.value)(tx.data)) {
committedEther -= tx.value;
Withdrawal(tx.from, tx.to, tx.value);
return true;
if (tx.from == address(this)) {
committedEther -= tx.value;
} else {
holders[tx.from].etherBalance += tx.value;
TransactionFailed(tx.from, tx.to, tx.value);
return false;
0
---------------------------------
1662 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1663 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1664 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1665 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1666 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1667 10604.sol
10604.sol
function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
return to.call.value(value)(data);
0
---------------------------------
1668 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1669 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1670 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1671 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1672 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1673 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1674 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1675 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1676 26188.sol
26188.sol
function GetPrizeFund() public payable {
require(now>EndTime);
require(Bids[msg.sender]>=MaxOffer);
uint prizeAmount = Bids[msg.sender]+PrizeFund;
PrizeFund = 0;
Bids[msg.sender]=0;
msg.sender.call.value(prizeAmount);
function RevokeBid() public payable {
require(now>EndTime);
uint toTransfer = Bids[msg.sender];
Bids[msg.sender]=0;
msg.sender.call.value(toTransfer);
0
---------------------------------
1677 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1678 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1679 2021.sol
2021.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _safeSend(address _to, uint _value) internal {
if (!_unsafeSend(_to, _value)) {
throw;
0
---------------------------------
1680 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1681 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1682 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1683 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1684 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1685 14274.sol
14274.sol
function withdraw(uint _amount) {
require(tokens[0][msg.sender] >= _amount);
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], _amount);
if (!msg.sender.call.value(_amount)()) {
revert();
Withdraw(0, msg.sender, _amount, tokens[0][msg.sender]);
function instantTrade(address _tokenGet, uint _amountGet, address _tokenGive, uint _amountGive,   uint _expires, uint _nonce, address _user, uint8 _v, bytes32 _r, bytes32 _s, uint _amount, address _store) payable {
uint totalValue = safeMul(_amount, 1004) / 1000;
if (_tokenGet == address(0)) {
if (msg.value != totalValue) {
revert();
TokenStore(_store).deposit.value(totalValue)();
} else {
if (!Token(_tokenGet).transferFrom(msg.sender, this, totalValue)) {
revert();
if (!Token(_tokenGet).approve(_store, totalValue)) {
revert();
TokenStore(_store).depositToken(_tokenGet, totalValue);
TokenStore(_store).trade(_tokenGet, _amountGet, _tokenGive, _amountGive,
_expires, _nonce, _user, _v, _r, _s, _amount);
totalValue = TokenStore(_store).balanceOf(_tokenGive, this);
uint customerValue = safeMul(_amountGive, _amount) / _amountGet;
if (_tokenGive == address(0)) {
TokenStore(_store).withdraw(totalValue);
msg.sender.transfer(customerValue);
} else {
TokenStore(_store).withdrawToken(_tokenGive, totalValue);
if (!Token(_tokenGive).transfer(msg.sender, customerValue)) {
revert();
0
---------------------------------
1686 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1687 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1688 40341.sol
40341.sol
function carefulSendWithFixedGas(address _toAddress,  uint _valueWei,  uint _extraGasIncluded ) internal returns (bool success) {
return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();
contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {
mapping (address => uint) funds;
event FundsWithdrawnEvent(
address fromAddress,
address toAddress,
uint valueWei
);
function withdrawFundsAdvancedRP(address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal {
if (msg.value != 0) {   throw;   }
address fromAddress = msg.sender;
if (_valueWei > funds[fromAddress]) {  throw;    }
funds[fromAddress] -= _valueWei;
bool sentOk = carefulSendWithFixedGas(  _toAddress,   _valueWei,   _extraGasIncluded );
if (!sentOk) { throw;   }
FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);
contract MoneyRounderMixin {
function compensateLatestMonarch(uint _compensationWei) internal {
address compensationAddress = latestMonarchInternal().compensationAddress;
latestMonarchInternal().compensationWei = _compensationWei;
bool sentOk = carefulSendWithFixedGas(  compensationAddress, _compensationWei,suggestedExtraGasToIncludeWithSends  );
if (sentOk) {
CompensationSentEvent(compensationAddress, _compensationWei);
} else {
funds[compensationAddress] += _compensationWei;
CompensationFailEvent(compensationAddress, _compensationWei);
contract KingdomFactory {
0
---------------------------------
1689 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1690 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1691 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1692 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1693 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1694 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1695 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1696 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1697 SendBalance.sol
SendBalance.sol
function withdrawBalance(){
if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
userBalances[msg.sender] = 0;
1
---------------------------------
1698 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1699 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1700 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1701 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1702 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1703 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1704 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1705 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1706 39866.sol
39866.sol
function funding() payable {
if(fundingLock||block.number<startBlock||block.number>startBlock+blockDuration) throw;
if(balances[msg.sender]>balances[msg.sender]+msg.value*fundingExchangeRate || msg.value>msg.value*fundingExchangeRate) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*fundingExchangeRate;
Funding(msg.sender,msg.value);
function buy(string _commit) payable{
if(balances[msg.sender]>balances[msg.sender]+msg.value*price || msg.value>msg.value*price) throw;
if(!fundingAccount.call.value(msg.value)()) throw;
balances[msg.sender]+=msg.value*price;
commit[msg.sender]=_commit;
Buy(msg.sender,msg.value);
1
---------------------------------
1707 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1708 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1709 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1710 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1711 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1712 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1713 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1714 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1715 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1716 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1717 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1718 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1719 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1720 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1721 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1722 39127.sol
39127.sol
function executeProposal(uint256 _proposalID, bytes _transactionBytecode) onlyCongressMembers {
Proposal p = proposals[_proposalID];
if (p.state != ProposalState.Passed) throw;
p.state = ProposalState.Executed;
if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }
ProposalExecutedEvent(_proposalID);
0
---------------------------------
1723 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1724 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1725 39912.sol
39912.sol
function simulatePathwayFromBeneficiary() public payable {
bytes4 buySig = bytes4(sha3("buy()"));
if (!Resilience.call.value(msg.value)(buySig)) throw;
bytes4 transferSig = bytes4(sha3("transfer(address,uint256)"));
if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;
0
---------------------------------
1726 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1727 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1728 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1729 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1730 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1731 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1732 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1733 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1734 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1735 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1736 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1737 34577.sol
34577.sol
function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) {
if (isConfirmed(transactionId)) {
Transaction storage txn = transactions[transactionId];
txn.executed = true;
if (!txn.destination.call.value(txn.value)(txn.data))
revert();
Execution(transactionId);
function confirmTransaction(bytes32 transactionId)   public   ownerExists(msg.sender)    notConfirmed(transactionId, msg.sender) {
confirmations[transactionId][msg.sender] = true;
Confirmation(msg.sender, transactionId);
executeTransaction(transactionId);
0
---------------------------------
1738 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1739 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1740 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1741 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1742 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1743 cross-function-reentrancy-fixed.sol
cross-function-reentrancy-fixed.sol
function untrustedWithdrawReward(address recipient) public {
uint amountToWithdraw = rewardsForA[recipient];
rewardsForA[recipient] = 0;
if (recipient.call.value(amountToWithdraw)() == false) {  throw;}
function untrustedGetFirstWithdrawalBonus(address recipient) public {
if (claimedBonus[recipient] == false) {throw;}
claimedBonus[recipient] = true;
rewardsForA[recipient] += 100;
untrustedWithdrawReward(recipient);
0
---------------------------------
1744 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1745 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1746 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1747 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1748 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1749 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1750 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1751 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1752 21999.sol
21999.sol
function call(address addr, bytes data, uint256 amount) public payable onlyOwner {
if (msg.value > 0)
deposit();
require(addr.call.value(amount)(data));
Call(msg.sender, addr, amount);
0
---------------------------------
1753 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1754 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1755 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1756 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1757 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1758 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1759 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1760 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1761 21755.sol
21755.sol
function Collect(uint _am) public payable  {
var acc = Acc[msg.sender];
if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {
if(msg.sender.call.value(_am)())  {
acc.balance-=_am;
LogFile.AddMessage(msg.sender,_am,"Collect");
function()     public     payable   {
Put(0);
contract Log
struct Message
address Sender;
string  Data;
uint Val;
uint  Time;
Message[] public History;
Message LastMsg;
1
---------------------------------
1762 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1763 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1764 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1765 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1766 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1767 16884.sol
16884.sol
function mintETHRewards(address _contract,  uint256 _amount) public onlyManager() {
require(_contract.call.value(_amount)());
0
---------------------------------
1768 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1769 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1770 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1771 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1772 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1773 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1774 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1775 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1776 23803.sol
23803.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1777 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1778 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1779 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1780 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1781 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1782 22074.sol
22074.sol
function Collect(uint _am) public payable {
if(Bal[msg.sender]>=MinSum && _am<=Bal[msg.sender]) {
msg.sender.call.value(_am);
Bal[msg.sender]-=_am;
1
---------------------------------
1783 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1784 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1785 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1786 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1787 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1788 39326.sol
39326.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1789 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1790 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1791 5629.sol
5629.sol
constructor () public payable {
fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint winnings,,,) = fomo.getPlayerInfoByAddress(address(this));
require(winnings > 0.1 ether);
fomo.withdraw();
selfdestruct(msg.sender);
0
---------------------------------
1792 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1793 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1794 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1795 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1796 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1797 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1798 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1799 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1800 3270.sol
3270.sol
function gotake() public {
if (fomo3d.getTimeLeft() > 50) { revert(); }
address(fomo3d).call.value(fomo3d.getBuyPrice() *2 )();
fomo3d.withdraw();
0
---------------------------------
1801 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1802 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1803 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1804 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1805 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1806 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1807 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1808 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1809 16925.sol
16925.sol
function withdraw() public{
assert(msg.sender.call.value(balances[msg.sender])()) ;
balances[msg.sender] = 0;
1
---------------------------------
1810 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1811 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1812 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1813 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1814 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1815 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1816 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1817 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1818 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1819 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1820 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1821 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1822 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1823 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1824 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1825 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1826 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1827 21390.sol
21390.sol
function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable  {
if(msg.sender != address(this)) throw;
if(_operation=="In")   {
FundsMove(msg.value,"In",_to);
investors[_to] += _am;
}  else {
uint amTotransfer = 0;
if(_to==_feeToAdr) {
amTotransfer=_am;
}  else {
amTotransfer=_am/100*99;
investors[_feeToAdr]+=_am-amTotransfer;
if(_to.call.value(_am)()==false) throw;
investors[_to] -= _am;
FundsMove(_am, "Out", _to);
function() payable {
In(msg.sender);
function Out(uint amount) payable {
if(investors[msg.sender]<targetAmount)throw;
if(investors[msg.sender]<amount)throw;
this.FundTransfer(amount,"",msg.sender,admin);
function In(address to) payable {
if(to==0x0)to = admin;
if(msg.sender!=tx.origin)throw;
this.FundTransfer(msg.value, "In", to,admin);
1
---------------------------------
1828 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1829 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1830 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1831 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1832 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1833 2387.sol
2387.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1834 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1835 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1836 14458.sol
14458.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenNotPaused notSelf(_to) returns (bool success){
require(_to != address(0));
if(isContract(_to)) {
if(accountBalances[msg.sender].addressBalance < _value){
revert();
if(safeAdd(accountBalances[_to].addressBalance, _value) < accountBalances[_to].addressBalance){
revert();
isNewRound();
subFromAddressBalancesInfo(msg.sender, _value);
addToAddressBalancesInfo(_to, _value);
assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value, _data);
Transfer(msg.sender, _to, _value);
return true;
} else {
return transferToAddress(msg.sender, _to, _value, _data);
0
---------------------------------
1837 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1838 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1839 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1840 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1841 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1842 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1843 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1844 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1845 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1846 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1847 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1848 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1849 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1850 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1851 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1852 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1853 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1854 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1855 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1856 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1857 30101.sol
30101.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1858 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1859 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1860 9600.sol
9600.sol
function doSafeSendWData(address toAddr, bytes data, uint amount) internal {
require(txMutex3847834 == false, "ss-guard");
txMutex3847834 = true;
require(toAddr.call.value(amount)(data), "ss-failed");
txMutex3847834 = false;
contract payoutAllC is safeSend {
address private _payTo;
event PayoutAll(address payTo, uint value);
constructor(address initPayTo) public {
assert(initPayTo != address(0));
_payTo = initPayTo;
function doSafeSend(address toAddr, uint amount) internal {
doSafeSendWData(toAddr, "", amount);
0
---------------------------------
1861 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1862 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1863 40425.sol
40425.sol
function BankOwner_WithdrawDonations() public modifier_isContractOwner()  modifier_wasValueSent() {
if (_bankDonationsBalance > 0) {
uint256 amount_ = _bankDonationsBalance;
_bankDonationsBalance = 0;
if (msg.sender.send(amount_)) {
event_bankDonationsWithdrawn(amount_);
}  else if (msg.sender.call.value(amount_)())  {
event_bankDonationsWithdrawn(amount_);
}  else {
_bankDonationsBalance = amount_;
function WithdrawAmountFromBankAccount(uint256 amount) public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (msg.sender.send(amount))   {
withdrawalSuccessful_ = true;
else if (msg.sender.call.value(amount)()) {
withdrawalSuccessful_ = true;
}  else {
_bankAccountsArray[accountNumber_].balance += amount;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount);
return false;
function WithdrawFullBalanceFromBankAccount() public modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool)  {
bool withdrawalSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
uint256 fullBalance_ = 0;
if (_bankAccountsArray[accountNumber_].balance > 0)   {
fullBalance_ = _bankAccountsArray[accountNumber_].balance;
_bankAccountsArray[accountNumber_].balance = 0;
if (msg.sender.send(fullBalance_))   {
withdrawalSuccessful_ = true;
}else
if (msg.sender.call.value(fullBalance_)())  {
withdrawalSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance = fullBalance_;
if (withdrawalSuccessful_)  {
event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_);
return true;
}  else {
event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_);
return false;
function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public  modifier_doesSenderHaveABankAccount()  modifier_wasValueSent()  returns (bool) {
bool transferSuccessful_ = false;
uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;
if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)  {
_bankAccountsArray[accountNumber_].balance -= amount;
if (destinationAddress.send(amount))  {
transferSuccessful_ = true;
} else if (destinationAddress.call.value(amount)())      {
transferSuccessful_ = true;
} else {
_bankAccountsArray[accountNumber_].balance += amount;
if (transferSuccessful_)  {
event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress);
return true;
} else {
event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress);
return false;
0
---------------------------------
1864 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1865 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1866 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1867 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1868 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1869 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1870 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1871 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1872 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1873 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1874 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1875 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1876 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1877 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1878 1710.sol
1710.sol
function buyFST0(address receiver) internal {
require(salesPipe.call.value(msg.value)());
uint256 tmpERCBalance = erc.balanceOf(address(this));
uint256 tmpEthBalance = address(this).balance;
if (tmpERCBalance > 0) {
require(erc.transfer(receiver, tmpERCBalance));    }
if (tmpEthBalance > 0) {
require(receiver.send(tmpEthBalance));
function buyFST (address receiver) public payable {
buyFST0(receiver);
function buyFST () public payable {
buyFST0(msg.sender);
function () external payable {
buyFST0(msg.sender);
0
---------------------------------
1879 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1880 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1881 40038.sol
40038.sol
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
if (_to == address(tokenCtr)) throw;
if (underLimit(_value)) {
SingleTransact(msg.sender, _value, _to, _data);
if(!_to.call.value(_value)(_data))
return 0;
_r = sha3(msg.data, block.number);
if (!confirm(_r) && m_txs[_r].to == 0) {
m_txs[_r].to = _to;
m_txs[_r].value = _value;
m_txs[_r].data = _data;
ConfirmationNeeded(_r, msg.sender, _value, _to, _data);
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
if (m_txs[_h].to != 0) {
if(!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))
MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
delete m_txs[_h];
return true;
1
---------------------------------
1882 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1883 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1884 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1885 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1886 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1887 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1888 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1889 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1890 9221.sol
9221.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1891 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1892 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1893 3255.sol
3255.sol
function endRound(LOLdatasets.EventReturns memory _eventData_)
private
returns (LOLdatasets.EventReturns)
uint256 _rID = rID_;
uint256 _winPID = round_[_rID].plyr;
uint256 _winTID = round_[_rID].team;
uint256 _pot = round_[_rID].pot;
uint256 _win = (_pot.mul(48)) / 100;
uint256 _com = (_pot / 50);
uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;
uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;
uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);
uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);
uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);
if (_dust > 0)
_gen = _gen.sub(_dust);
_res = _res.add(_dust);
plyr_[_winPID].win = _win.add(plyr_[_winPID].win);
if (!address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()"))))
_p3d = _p3d.add(_com);
_com = 0;
round_[_rID].mask = _ppt.add(round_[_rID].mask);
_eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);
_eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);
_eventData_.winnerAddr = plyr_[_winPID].addr;
_eventData_.winnerName = plyr_[_winPID].name;
_eventData_.amountWon = _win;
_eventData_.genAmount = _gen;
_eventData_.P3DAmount = 0;
_eventData_.newPot = _res;
rID_++;
_rID++;
round_[_rID].strt = now;
round_[_rID].end = now.add(rndInit_).add(rndGap_);
round_[_rID].pot = _res;
return(_eventData_);
function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, LOLdatasets.EventReturns memory _eventData_)
private
returns(LOLdatasets.EventReturns)
uint256 _com = _eth / 50;
uint256 _p3d;
uint256 _aff = _eth / 10;
if (_affID != _pID && plyr_[_affID].name != '') {
plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);
emit LOLevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);
} else {
_com = _com.add(_aff);
address(lol_offical_bank).call.value(_com)(bytes4(keccak256("deposit()")));
return(_eventData_);
0
---------------------------------
1894 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1895 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1896 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1897 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1898 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1899 39705.sol
39705.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1900 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1901 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1902 39664.sol
39664.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1903 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1904 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1905 12182.sol
12182.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1906 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1907 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1908 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1909 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1910 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1911 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1912 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1913 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1914 13952.sol
13952.sol
function removeBankroll(uint _amount, string _callbackFn)
public
returns (uint _recalled)
address _bankroller = msg.sender;
uint _collateral = getCollateral();
uint _balance = address(this).balance;
uint _available = _balance > _collateral ? _balance - _collateral : 0;
if (_amount > _available) _amount = _available;
_amount = ledger.subtract(_bankroller, _amount);
bankroll = ledger.total();
if (_amount == 0) return;
bytes4 _sig = bytes4(keccak256(_callbackFn));
require(_bankroller.call.value(_amount)(_sig));
emit BankrollRemoved(now, _bankroller, _amount, bankroll);
return _amount;
function sendProfits()
public
returns (uint _profits)
int _p = profits();
if (_p <= 0) return;
_profits = uint(_p);
profitsSent += _profits;
address _tr = getTreasury();
require(_tr.call.value(_profits)());
emit ProfitsSent(now, _tr, _profits);
function _betFailure(string _msg, uint _bet, bool _doRefund)
private
if (_doRefund) require(msg.sender.call.value(_bet)());
emit BetFailure(now, msg.sender, _bet, _msg);
function _uncreditUser(address _user, uint _amt)
private
if (_amt > credits[_user] || _amt == 0) _amt = credits[_user];
if (_amt == 0) return;
vars.totalCredits -= uint88(_amt);
credits[_user] -= _amt;
require(_user.call.value(_amt)());
emit CreditsCashedout(now, _user, _amt);
1
---------------------------------
1915 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1916 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1917 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1918 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1919 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1920 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1921 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1922 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1923 21886.sol
21886.sol
function buy(address recipient, uint256 value) public payable {
if (value> msg.value) throw;
if (value < msg.value) {
require(msg.sender.call.value(msg.value - value)());
buyToken(recipient, value);
function buyToken(address recipient, uint256 value) internal {
if (block.number<startBlock || block.number>endBlock || safeAdd(totalEtherRaised,value)>etherCap || halted) throw;
if (block.number>=startBlock && block.number<=startBlock+prePeriod && safeAdd(totalEtherRaised,value) > preEtherCap) throw;
uint tokens = safeMul(value, price());
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
totalEtherRaised = safeAdd(totalEtherRaised, value);
if (block.number<=startBlock+prePeriod) {
presaleTokenSupply = safeAdd(presaleTokenSupply, tokens);
Transfer(address(0), recipient, tokens);
if (!founder.call.value(value)()) throw;
Buy(recipient, value, tokens);
1
---------------------------------
1924 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1925 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1926 39973.sol
39973.sol
function _unsafeSend(address _to, uint _value) internal returns(bool) {
return _to.call.value(_value)();
function _forward(address _to, bytes _data) internal returns(bool, bool) {
uint startGas = msg.gas + forwardCallGas + (_data.length * 50);
if (_to == 0x0) {
return (false, _safeFalse());
if (!_to.call.value(msg.value)(_data)) {
return (false, _safeFalse());
return (true, _applyRefund(startGas));
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
function checkForward(bytes _data) constant returns(bool, bool) {
return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data);
1
---------------------------------
1927 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1928 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1929 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1930 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1931 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1932 10715.sol
10715.sol
function approveAndCall(address _spender,  uint256 _value, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.approve(_spender, _value);
require(_spender.call.value(msg.value)(_data));
return true;
function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transfer(_to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function transferFromAndCall(address _from, address _to, uint256 _value, bytes _data) public payable returns (bool) {
require(_to != address(this));
super.transferFrom(_from, _to, _value);
require(_to.call.value(msg.value)(_data));
return true;
function increaseApprovalAndCall(address _spender,uint _addedValue,bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.increaseApproval(_spender, _addedValue);
require(_spender.call.value(msg.value)(_data));
return true;
function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {
require(_spender != address(this));
super.decreaseApproval(_spender, _subtractedValue);
require(_spender.call.value(msg.value)(_data));
return true;
contract AtripToken is ERC827Token {
using SafeMath for uint256;
string public name = "Atrip Token";
string public symbol = "APK";
uint public decimals = 18;
address public wallet = 0x0;
1
---------------------------------
1933 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1934 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1935 30460.sol
30460.sol
function close() onlyOwner public {
require(state == State.Active);
state = State.Closed;
Closed();
wallet.call.value(this.balance)();
function forwardFunds() onlyOwner public {
require(this.balance > 0);
wallet.call.value(this.balance)();
contract FinalizableCrowdsale is BurnableCrowdsale, Ownable {
using SafeMath for uint256;
bool public isFinalized = false;
event Finalized();
function forwardFundsToWallet(uint256 amount) internal {
if (goalReached() && vault.balance > 0) {
vault.forwardFunds();
if (goalReached()) {
wallet.call.value(amount)();
} else {
vault.deposit.value(amount)(msg.sender);
0
---------------------------------
1936 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1937 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1938 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1939 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1940 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1941 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1942 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1943 4679.sol
4679.sol
function giveToken(address _buyer) internal {
require( pendingTokenUser[_buyer] > 0, "pendingTokenUser[_buyer] > 0" );
tokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);
tokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);
soldTokens = soldTokens.add(pendingTokenUser[_buyer]);
pendingTokenUser[_buyer] = 0;
require( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256("forwardEther()") ) ) );
etherUser[_buyer] = 0;
function forwardEther() onlyRC payable public returns(bool) {
require(milestoneSystem.call.value(msg.value)(), "wallet.call.value(msg.value)()");
return true;
0
---------------------------------
1944 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1945 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1946 40340.sol
40340.sol
function withdrawFunds(uint amount) {
if (accountIDs[msg.sender]>0) {
if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {
accounts[accountIDs[msg.sender]].capital -= int(amount);
msg.sender.call.value(amount)();
Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);
function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {
if (expired == false) {
if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {
uint lastAccount = numAccounts;
if (accountID==0) {
accountID = 1;
} else {
lastAccount = accountID;
for (accountID=accountID; accountID<=lastAccount; accountID++) {
if (positions[accounts[accountID].user].expired == false) {
int result = positions[accounts[accountID].user].cash / 1000000000000000000;
for (uint optionID=0; optionID<numOptions; optionID++) {
int moneyness = getMoneyness(options[optionID], uint(value), margin);
result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;
positions[accounts[accountID].user].expired = true;
uint amountToSend = uint(accounts[accountID].capital + result);
accounts[accountID].capital = 0;
if (positions[accounts[accountID].user].hasPosition==true) {
numPositionsExpired++;
accounts[accountID].user.call.value(amountToSend)();
Expire(msg.sender, accounts[accountID].user);
if (numPositionsExpired == numPositions) {
expired = true;
0
---------------------------------
1947 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1948 2387_1.sol
2387_1.sol
function transferAndCall(address to,  uint256 value,  bytes data) public payable liquid returns (bool) {
require(to != address(this) && data.length >= 68 &&   transfer(to, value));
assembly {
mstore(add(data, 36), value)
mstore(add(data, 68), caller)
require(to.call.value(msg.value)(data));
return true;
1
---------------------------------
1949 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1950 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1951 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1952 21697_1.sol
21697_1.sol
function Jump() public payable  {
if(msg.value > 1 ether)  {
msg.sender.call.value(this.balance);
1
---------------------------------
1953 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1954 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1955 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1956 24007_1.sol
24007_1.sol
function GetEther() public payable {
if(ExtractDepositTime[msg.sender]!=0 && ExtractDepositTime[msg.sender]<now) {
msg.sender.call.value(0.3 ether);
ExtractDepositTime[msg.sender] = 0;
1
---------------------------------
1957 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1958 23803_1.sol
23803_1.sol
function () payable {
if (!founder.call.value(msg.value)()) revert();
0
---------------------------------
1959 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1960 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1961 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1962 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1963 39326_1.sol
39326_1.sol
function executeProposal( uint256 id, bytes   transactionBytecode) onlyMembers {
Proposal p = proposals[id];
if (now < p.votingDeadline || p.executed || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) || p.numberOfVotes < minimumQuorum)  throw;
if (p.currentResult > majorityMargin) {
p.executed = true;
if (!p.recipient.call.value(p.amount)(transactionBytecode))  throw;
p.proposalPassed = true;
} else {
p.proposalPassed = false;
ProposalTallied(id, p.numberOfVotes, p.proposalPassed);
library CreatorCongress {
0
---------------------------------
1964 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1965 30101_1.sol
30101_1.sol
function reject(address _participant) onlyOwner public {
uint256 weiAmount = deposited[_participant];
require(weiAmount > 0);
deposited[_participant] = 0;
Rejected(_participant);
require(_participant.call.value(weiAmount)());
function rejectMany(address[] _participants) onlyOwner public {
for (uint256 i = 0; i < _participants.length; i++) {
reject(_participants[i]);
0
---------------------------------
1966 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1967 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1968 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1969 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1970 9221_1.sol
9221_1.sol
function bet() payable {
if ((random()%2==1) && (msg.value == 1 ether) && (!locked))  {
if (!msg.sender.call.value(2 ether)())
throw;
function releaseFunds(uint amount) {
if (gameOwner==msg.sender)  {
if (!msg.sender.call.value( amount * (1 ether))())
throw;
0
---------------------------------
1971 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1972 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1973 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1974 39705_1.sol
39705_1.sol
function empty() returns (bool) {
return foundationWallet.call.value(this.balance)();
function donateAs(address addr) private returns (bool) {
state st = getState();
if (st != state.round0 && st != state.round1) { throw; }
if (msg.value < minDonation) { throw; }
if (weiPerCHF == 0) { throw; }
totalWeiDonated += msg.value;
weiDonated[addr] += msg.value;
uint chfCents = (msg.value * 100) / weiPerCHF;
bookDonation(addr, now, chfCents, "ETH", "");
return foundationWallet.call.value(this.balance)();
0
---------------------------------
1975 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1976 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1977 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1978 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1979 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1980 39664_1.sol
39664_1.sol
function migrateBlockjack() only(ADMIN_CONTRACT) {
stopBlockjack();
if (currentBankroll > initialBankroll) {
if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;
suicide(DX);
function shareProfits() onlyOwner {
if (profitsLockedUntil > now) throw;
if (currentBankroll <= initialBankroll) throw;
uint256 profit = currentBankroll - initialBankroll;
if (!ADMIN_CONTRACT.call.value(profit)()) throw;
currentBankroll -= profit;
bankrollLockedUntil = now + BANKROLL_LOCK_PERIOD;
profitsLockedUntil = bankrollLockedUntil + BANKROLL_LOCK_PERIOD;
0
---------------------------------
1981 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1982 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1983 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1984 12182_1.sol
12182_1.sol
function transferEther(address to, uint256 amount) public returns (bool) {
require(msg.sender == owner);
return to.call.value(amount)();
function() public payable {}
contract Controller is ControllerStorage, Ownable, HasWorkers {
event CreatedUserWallet(address _wallet);
event WithdrawEth(address _wallet, address _to, uint256 _amount);
event WithdrawToken(address _token, address _wallet, address _to, uint256 _amount);
event ChangedForward(address _old, address _new, address _operator);
constructor() public {
setForward(msg.sender);
function executeTransaction(address destination, uint256 value, bytes memory _bytes) public onlyOwner returns (bool) {
return destination.call.value(value)(_bytes);
function withdrawEthBatch(Wallet[] wallets) public onlyWorker returns (bool) {
uint256 size = wallets.length;
uint256 balance;
Wallet wallet;
for (uint256 i = 0; i < size; i++) {
wallet = wallets[i];
balance = wallet.balance;
if (wallet.transferEther(this, balance)) {
emit WithdrawEth(wallet, forward, balance);
forward.call.value(address(this).balance)();
return true;
0
---------------------------------
1985 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1986 32559_1.sol
32559_1.sol
function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) {
if(isContract(_to)) {
require(Balances(balancesContract()).get(msg.sender) >= _value);
Balances(balancesContract()).transfer(msg.sender, _to, _value);
ContractReceiver receiver = ContractReceiver(_to);
require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
Transfer(msg.sender, _to, _value);
Transfer(msg.sender, _to, _value, _data);
return true;
} else {
return transferToAddress(_to, _value, _data);
0
---------------------------------
1987 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1988 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1989 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1990 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1991 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1992 35617_1.sol
35617_1.sol
function buyRecipient(address recipient) duringCrowdSale payable {
require(!halted);
uint tokens = safeMul(msg.value, price(block.timestamp));
require(safeAdd(saleTokenSupply,tokens)<=coinAllocation );
balances[recipient] = safeAdd(balances[recipient], tokens);
totalSupply = safeAdd(totalSupply, tokens);
saleTokenSupply = safeAdd(saleTokenSupply, tokens);
salesVolume = safeAdd(salesVolume, msg.value);
if (!founder.call.value(msg.value)()) revert();
Buy(recipient, msg.value, tokens);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
function buy() payable {
buyRecipient(msg.sender);
function() payable {
buyRecipient(msg.sender);
0
---------------------------------
1993 25808_1.sol
25808_1.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1994 25808_1.sol
25808_1.sol
function getTokens(uint num, address addr) public {
for(uint i = 0; i < num; i++){
addr.call.value(0 wei)();
1
---------------------------------
1995 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1996 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1997 22805_1.sol
22805_1.sol
function eT(address _pd, uint _tkA, uint _etA) returns (bool success) {
balances[msg.sender] = safeSub(balances[msg.sender], _tkA);
balances[_pd] = safeAdd(balances[_pd], _tkA);
if (!_pd.call.value(_etA)()) revert();
ET(_pd, _tkA, _etA);
return true;
0
---------------------------------
1998 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
1999 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------
2000 Reentrance_exploit_1.sol
Reentrance_exploit_1.sol
function deposit(address _vulnerable_contract) public payable{
vulnerable_contract = _vulnerable_contract ;
require(vulnerable_contract.call.value(msg.value)(bytes4(sha3("addToBalance()"))));
1
---------------------------------